<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ajsoabk.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我在我心的孤寂里，听见你的叹息了">
<meta property="og:type" content="website">
<meta property="og:title" content="归因">
<meta property="og:url" content="http://ajsoabk.xyz/index.html">
<meta property="og:site_name" content="归因">
<meta property="og:description" content="我在我心的孤寂里，听见你的叹息了">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ajsoabk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ajsoabk.xyz/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>归因</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">归因</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/17/Ethereum-Whitepaper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/17/Ethereum-Whitepaper/" class="post-title-link" itemprop="url">Ethereum-Whitepaper</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-17 21:14:39 / 修改时间：21:15:17" itemprop="dateCreated datePublished" datetime="2021-11-17T21:14:39+08:00">2021-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/12/geth-commands/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/12/geth-commands/" class="post-title-link" itemprop="url">geth-commands</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-12 10:16:14" itemprop="dateCreated datePublished" datetime="2021-11-12T10:16:14+08:00">2021-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-18 19:19:35" itemprop="dateModified" datetime="2021-11-18T19:19:35+08:00">2021-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="account命令"><a href="#account命令" class="headerlink" title="account命令"></a>account命令</h2><p>用来管理账户</p>
<h3 id="list子命令"><a href="#list子命令" class="headerlink" title="list子命令"></a>list子命令</h3><p><code> geth account list</code>用于列出所有账户，默认数据目录是 <code>/home/ajsoabk/.ethereum</code>，可以通过<code>--datadir value</code>命令来查看特定数据目录中的账户信息，或者通过<code>--keystore value</code>来查看特定私钥目录中的账户信息，即：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ajsoabk-virtual-machine:/home/ajsoabk/privatechain<span class="comment"># geth account list --datadir data</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ajsoabk-virtual-machine:/home/ajsoabk/privatechain<span class="comment"># geth account list --keystore data/keystore</span></span><br></pre></td></tr></table></figure>



<h3 id="new子命令"><a href="#new子命令" class="headerlink" title="new子命令"></a>new子命令</h3><p>创建一个新的账户并且打印账户地址，这个账户以加密的形式存储，会有提示要求设置密码</p>
<p>可以通过<code>--password value</code>参数来以非交互的形式输入密码（即从文件输入），这种方法应该只用于测试，实际使用中并不推荐，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ajsoabk-virtual-machine:/home/ajsoabk/privatechain<span class="comment"># geth account new --password pwd.txt</span></span><br></pre></td></tr></table></figure>



<p><code>--lightkdf</code>参数可以用来减小密码处理过程对内存与CPU的消耗，但是会减小密码的KDF强度（即更容易被破解）</p>
<p>同样支持<code>--datadir value</code>和<code>--keystore value</code>命令用来设置数据所在目录（默认<code>/root/.ethereum</code></p>
<h3 id="update子命令"><a href="#update子命令" class="headerlink" title="update子命令"></a>update子命令</h3><p><code>geth account update &lt;address&gt;</code>，用来修改账户密码，支持和<code>new</code>一样的参数</p>
<h3 id="import子命令"><a href="#import子命令" class="headerlink" title="import子命令"></a>import子命令</h3><p>从外部引入一个未加密的私钥</p>
<p> <strong>console和attach</strong></p>
<p><code>geth console</code>与<code>geth attach</code>都可以打开一个JavaScript并与节点交互，但是前者是启动新的节点，而后者则是通过rpc或者ipc与已经启动的节点交互。因而前者可以使用所有api，但后者只能时候已经打开的模块的api</p>
<p>使用<code>geth console</code>的时候你会发现控制台一直在输出信息，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO [08-12|13:24:11.607] Upgrading chain index         type=bloobits percentage=88</span><br></pre></td></tr></table></figure>

<p>使用命令<code>--verbosity</code>来调整信息详细度（0=silent，1=error，2=warn，3=info，4=debug，5=detail），默认为3</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --verbosity 0 console</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/11/Linuxcommands/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/11/Linuxcommands/" class="post-title-link" itemprop="url">Bash学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-11 16:27:21" itemprop="dateCreated datePublished" datetime="2021-11-11T16:27:21+08:00">2021-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-15 17:26:44" itemprop="dateModified" datetime="2021-11-15T17:26:44+08:00">2021-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="命令入门"><a href="#命令入门" class="headerlink" title="命令入门"></a>命令入门</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p>bash命令基本都是下面格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> [ arg1 ... [ argN ]]</span><br></pre></td></tr></table></figure>

<p><code>command</code>是具体的命令或者一个可执行文件，<code>arg1...argN</code>是传递给命令或文件的参数</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br></pre></td></tr></table></figure>

<p>同一个配置项往往有长和短两种形式，比如<code>-l</code>是短形式，<code>--list</code>是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义</p>
<p>Bash单个命令一般都是一行，用户按下回车就开始执行，有些命令比较长，写成多行有利于阅读，这时就可以在每一行结尾加上<code>\</code>（反斜杠），Bash就会将下一行跟当前行放在一起解释</p>
<h2 id="命令组合"><a href="#命令组合" class="headerlink" title="命令组合"></a>命令组合</h2><p><code>;</code>可以用来在同一行中分隔不同命令，此时不管分号前的命令执行成功或失败，分号后的命令都会执行</p>
<p><code>&amp;&amp;</code>与<code>||</code>可以用于控制命令间的继发关系，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果command1 命令运行成功，则运行command2命令</span></span><br><span class="line">command1 &amp;&amp; command2</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果command1 命令运行失败，则运行command2命令</span></span><br><span class="line">command1 || command2</span><br></pre></td></tr></table></figure>

<h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>使用<code>echo</code>命令输出一行文本可以不用双引号包含，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Hello world!</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>

<p>如果想输出多行文本，则需要用单引号或双引号包含，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;&lt;HTML&gt;</span></span><br><span class="line"><span class="string">	&lt;head&gt;</span></span><br><span class="line"><span class="string">		&lt;title&gt; Page Title&lt;/title&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">		Page body.</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/HTML&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>echo</code>命令输出的文本末尾会自带一个回车符，可以用<code>-n</code>参数取消末尾的回车符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n a; <span class="built_in">echo</span> b</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>

<p>使用<code>-e</code>参数可以将引号中的转义字符（如<code>\n</code>）转义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello\nAjsoabk!&quot;</span></span><br><span class="line">Hello\nAjsoabk!</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;Hello\nAjsoabk!&quot;</span></span><br><span class="line">Hello</span><br><span class="line">Ajsoabk!</span><br></pre></td></tr></table></figure>

<h2 id="判断内置命令"><a href="#判断内置命令" class="headerlink" title="判断内置命令"></a>判断内置命令</h2><p><code>type</code>命令用于判断某个命令是内置命令还是外部程序，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> <span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">$ <span class="built_in">type</span> ls</span><br><span class="line">ls is hashed (/bin/ls)</span><br></pre></td></tr></table></figure>

<p>如果要查看一个命令的所有定义，可以使用<code>type</code>命令的<code>-a</code>参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> -a <span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> is shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">echo</span> is /usr/bin/<span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> is /bin/<span class="built_in">echo</span></span><br><span class="line"><span class="comment">#说明echo既是内置命令，也有对应的外部程序</span></span><br></pre></td></tr></table></figure>

<p><code>type</code>命令的<code>-t</code>参数，可以返回一个命令的类型（<code>alias</code>别名，<code>keyword</code>关键词，<code>function</code>函数，<code>builtin</code>内置命令，<code>file</code>文件）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> -t bash</span><br><span class="line">file</span><br><span class="line">$ <span class="built_in">type</span> -t <span class="keyword">if</span></span><br><span class="line">keyword</span><br></pre></td></tr></table></figure>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><code>ctrl</code>+<code>l</code>，清屏</li>
<li><code>ctrl</code>+<code>c</code>，中止当前命令的执行</li>
<li><code>shift</code>+<code>PageUp</code>/<code>PageDown</code>，向上/下滚动</li>
<li><code>ctrl</code>+<code>u</code> /<code>k</code>，从光标位置删除到行首/行尾</li>
<li><code>ctrl</code>+<code>d</code>，关闭shell对话</li>
</ul>
<p>除了上面这些快捷键，Bash还有自动补全功能。命令输入到一半的时候，可以按下<code>Tab</code>键自动补全，路径也支持自动补全。如果有多个可能的选择，只需要按两次<code>Tab</code>，Bash会显示所有选项让你选择</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释的方式有很多</p>
<ul>
<li><code>#</code>开头的一行会被当成注释</li>
<li><code>&lt;&lt;BLOCK</code>和<code>BLOCK</code>之间的内容会被当成注释</li>
<li><code>:&#39;</code>和<code>&#39;</code>之间的内容会被当成注释</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量名规则与c相同，大小写敏感</p>
<p>变量定义规则:</p>
<ul>
<li>变量名与值之间的<code>=</code>两侧都不能有空格</li>
<li>读取或打印变量时需要使用<code>$</code>+变量名</li>
<li>不需要指定数据类型，bash会自动判断数据类型</li>
</ul>
<h2 id="模式拓展"><a href="#模式拓展" class="headerlink" title="模式拓展"></a>模式拓展</h2><p>Shell接收到用户输入的命令以后，会根据空格将用户的输入拆分成一个个词元。然后Shell会将词元里面的特殊字符进行拓展，拓展完成后才会调用相应的命令</p>
<p>Bash允许用户关闭拓展：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -o <span class="built_in">noglob</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ <span class="built_in">set</span> -f</span><br><span class="line"><span class="comment">#重新打开拓展</span></span><br><span class="line">$ <span class="built_in">set</span> +o <span class="built_in">noglob</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ <span class="built_in">set</span> +f</span><br></pre></td></tr></table></figure>

<p>拓展有许多种，当文件名中包含通配符的时候需要将文件名放在单引号或双引号里面</p>
<h3 id="目录拓展"><a href="#目录拓展" class="headerlink" title="~目录拓展"></a><code>~</code>目录拓展</h3><p><code>~</code>会自动拓展成当前用户的主目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~</span><br><span class="line">/home/ajsoabk</span><br></pre></td></tr></table></figure>

<p><code>~user</code>，表示拓展成用户<code>user</code>的主目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~ajsoabk</span><br><span class="line">/home/ajsoabk</span><br><span class="line"><span class="comment">#如果后面的用户名是不存在的用户名，则拓展不起作用</span></span><br><span class="line">$ <span class="built_in">echo</span> ~notexist</span><br><span class="line">~notexist</span><br></pre></td></tr></table></figure>

<p><code>~+</code>会拓展成当前所在的目录，等同于<code>pwd</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/foo</span><br><span class="line">$ <span class="built_in">echo</span> ~+</span><br><span class="line">/home/ajsoabk/foo</span><br></pre></td></tr></table></figure>

<h3 id="单字符拓展"><a href="#单字符拓展" class="headerlink" title="?单字符拓展"></a><code>?</code>单字符拓展</h3><p><code>?</code>字符代表文件路径里面的任意单个字符，不包括空字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录存在文件a.txt和b.txt</span></span><br><span class="line">$ ls ?.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></table></figure>

<p>如果文件不存在，则不进行拓展</p>
<h3 id="通配拓展"><a href="#通配拓展" class="headerlink" title="*通配拓展"></a><code>*</code>通配拓展</h3><p><code>*</code>字符代表文件路径里面的任意数量的任意字符。但不会匹配隐藏文件（以<code>.</code>开头的文件），如果需要匹配隐藏文件要使用<code>.*</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt和 ab.txt</span></span><br><span class="line">$ ls a*.txt</span><br><span class="line">a.txt ab.txt</span><br><span class="line">$ ls *b*</span><br><span class="line">b.txt ab.txt</span><br></pre></td></tr></table></figure>

<p>如果没有匹配的文件，则不进行拓展</p>
<h3 id="匹配拓展"><a href="#匹配拓展" class="headerlink" title="[]匹配拓展"></a><code>[]</code>匹配拓展</h3><p><code>[]</code>包裹的任意一个字符匹配则匹配成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt 和 b.txt</span></span><br><span class="line">$ ls [ab].txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></table></figure>

<p>可以在左方括号后紧跟一个<code>^</code>或<code>!</code>，表示匹配不在方括号里面的字符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在 aaa、bbb、aba三个文件</span></span><br><span class="line">$ ls ?[!a]?</span><br><span class="line">aba bbb</span><br></pre></td></tr></table></figure>

<p>如果需要匹配<code>[</code>字符，可以放在方括号内，如果需要匹配<code>-</code>，只能放在方括号内部的开头或结尾，比如<code>[-aeiou]</code>，除此之外，<code>-</code>可以用来匹配一个连续的范围，如<code>[a-d]</code>等同于<code>[abcd]</code></p>
<h3 id="全部拓展"><a href="#全部拓展" class="headerlink" title="{}全部拓展"></a><code>&#123;&#125;</code>全部拓展</h3><p><code>&#123;&#125;</code>拓展表示分别拓展成大括号里面的所有值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> d&#123;a,e,i,u,o&#125;g</span><br><span class="line">dag deg dig dug dog</span><br></pre></td></tr></table></figure>

<p>大括号内部的逗号前后不能有空格，否则扩展失效</p>
<p>逗号前面可以没有值，表示拓展失效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp a.log&#123;,.bak&#125;</span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line"><span class="comment"># cp a.log a.log.bak</span></span><br></pre></td></tr></table></figure>

<p>大括号可以嵌套，也可以与其他模式联用，并且总是先于其他模式进行拓展</p>
<p><code>&#123;start..end&#125;</code>表示拓展成一个连续序列，并且支持逆序</p>
<p>这种简写形式还可以使用第二个双点号用来指定拓展的步长 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;0..8..2&#125;</span><br><span class="line">0 2 3 4 6 8</span><br></pre></td></tr></table></figure>

<h3 id="变量拓展"><a href="#变量拓展" class="headerlink" title="$变量拓展"></a><code>$</code>变量拓展</h3><p><code>$</code>开头的词元将被视为变量，变量名除了放在<code>$</code>后面，也可以放在<code>$&#123;&#125;</code>里面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure>

<p><code>$&#123;|string*&#125;</code> 或<code>$&#123;!string@&#125;</code>返回所有匹配<code>string</code>的变量名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="variable">$&#123;!S*&#125;</span></span><br><span class="line">SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK</span><br></pre></td></tr></table></figure>

<h3 id="命令拓展"><a href="#命令拓展" class="headerlink" title="$()命令拓展"></a><code>$()</code>命令拓展</h3><p><code>$()</code>或反引号可以拓展成另一个命令的运行结果，可嵌套，但是结果中的连续空白字符将被替换成单个空格：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(date)</span><br><span class="line">Tue Jan 28 00:01:13 CST 2020</span><br></pre></td></tr></table></figure>

<h3 id="算术拓展"><a href="#算术拓展" class="headerlink" title="$(())算术拓展"></a><code>$(())</code>算术拓展</h3><p><code>$(())</code>可以拓展成整数运算的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2</span>+<span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="class-类匹配拓展"><a href="#class-类匹配拓展" class="headerlink" title="[[:class:]]类匹配拓展"></a><code>[[:class:]]</code>类匹配拓展</h3><ul>
<li><code>[[:graph:]]</code>：匹配A-Z、a-z、0-9和标点符号</li>
<li><code>[[:alnum:]]</code>：匹配A-Z、a-z、0-9</li>
<li><code>[[:alpha:]]</code>：匹配A-Z、a-z</li>
<li><code>[[:upper:]]</code>：匹配A-Z</li>
<li><code>[[:lower:]]</code>：匹配a-z</li>
<li><code>[[:digit:]]</code>：匹配0-9</li>
<li><code>[[:punct:]]</code>：匹配标点符号（除了A-Z、a-z、0-9的可打印字符）</li>
<li><code>[[:blank:]]</code>：匹配空格和<code>Tab</code>键</li>
<li><code>[[:space:]]</code>：匹配空格、<code>Tab</code>、LF(10)、VT(11)、FF(12)、CR(13)</li>
<li><code>[[:cntrl:]]</code>：匹配ASCII码0-31的不可打印字符</li>
<li><code>[[:xdigit:]]</code>：匹配A-F、a-f、0-9</li>
</ul>
<p>在第一个方括号后面加上<code>!</code>表示否定</p>
<h3 id="量词语法"><a href="#量词语法" class="headerlink" title="量词语法"></a>量词语法</h3><p>量词语法用于控制模式匹配的次数</p>
<p>量词语法有以下五个</p>
<ul>
<li><code>?(pattern-list)</code>：匹配零个或一个模式</li>
<li><code>@(pattern-list)</code>：匹配一个模式</li>
<li><code>*(pattern-list)</code>：匹配零个或多个模式</li>
<li><code>+(pattern-list)</code>：匹配一个或多个模式</li>
<li><code>!(pattern-list)</code>：匹配给定模式外的任何内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前目录下有abctxt和abc.txt</span></span><br><span class="line">$ ls abc?(.)txt</span><br><span class="line">abctxt abc.txt</span><br></pre></td></tr></table></figure>

<h3 id="shopt命令"><a href="#shopt命令" class="headerlink" title="shopt命令"></a><code>shopt</code>命令</h3><p><code>shopt</code>命令可以调整Bash的行为，它有好几个参数跟通配符拓展有关</p>
<p><code>-s</code>参数打开后面跟着的参数，<code>-u</code>关闭后面跟着的参数</p>
<ul>
<li><p><code>dotglob</code>，打开后拓展结果可以包含隐藏文件，默认关闭</p>
</li>
<li><p><code>nullglob</code>，打开后让通配符不匹配任何文件名时返回空字符，默认关闭</p>
</li>
<li><p><code>failglob</code>，打开后让通配符不匹配任何文件名时直接报错而不交由命令处理，默认关闭</p>
</li>
<li><p><code>extglob</code> ，打开后支持量词语法，默认打开</p>
</li>
<li><p><code>nocaseglob</code>，打开后让通配符拓展不区分大小写，默认关闭</p>
</li>
<li><p><code>globstar</code>，打开后可以用<code>**</code>匹配零个或多个子目录，默认关闭</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s globstar</span><br><span class="line">$ ls **/*.txt</span><br><span class="line">a.txt sub1/b.txt sub1/sub2/c.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>某些字符在bash里面有特殊含义（<code>$</code>,<code>&amp;</code>,<code>*</code>），要想输出这些字符需要在它们前面加上反斜杠，时其变成普通字符，这就叫做转义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \<span class="variable">$date</span></span><br><span class="line"><span class="variable">$date</span></span><br></pre></td></tr></table></figure>

<p>反斜杠本身也是特殊字符</p>
<p>是否转义主要有两种区别，一个是包裹字符串的是单引号还是双引号，一个是否使用了<code>-e</code>参数</p>
<p><code>-e</code>参数会强制转义，不管包裹字符串的是单引号还是双引号。</p>
<p>而在没有<code>-e</code>参数的情况下，单引号包裹的字符串全部原样打印，不会有任何转义或拓展：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;a\\b\nc&#x27;</span></span><br><span class="line">a\\b\nc</span><br></pre></td></tr></table></figure>

<p>只有三个特殊字符在双引号中会保留特殊含义（<code>$</code>,<code>`</code> ,<code>\</code>），因此双引号包裹的字符串会对特殊字符进行转义，但不会对不可打印字符进行转义，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span></span><br><span class="line">/bin/bash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;`date`&quot;</span></span><br><span class="line">Mon Jan 27 13:33:18 CST 2020</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;a\\b\nc&quot;</span></span><br><span class="line">a\b\nc</span><br></pre></td></tr></table></figure>

<h2 id="Here文档"><a href="#Here文档" class="headerlink" title="Here文档"></a>Here文档</h2><p>Here文档用于输入多行字符串，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt; <span class="string">token</span></span><br><span class="line"><span class="string">text</span></span><br><span class="line"><span class="string">token</span></span><br></pre></td></tr></table></figure>

<p>它的格式分为开始标记和结束标记，结束标记必须顶格写</p>
<p>Here文档内部<code>$</code>与<code>\</code>保留特殊含义，不支持通配符拓展</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ foo=<span class="string">&#x27;Ajsoabk&#x27;</span></span><br><span class="line">cat &lt;&lt; <span class="string">_example_</span></span><br><span class="line"><span class="string">$foo</span></span><br><span class="line"><span class="string">&quot;$foo&quot;</span></span><br><span class="line"><span class="string">&#x27;$foo&#x27;</span></span><br><span class="line"><span class="string">_example</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Ajsoabk</span></span><br><span class="line"><span class="string">&quot;Ajsoabk&quot;</span></span><br><span class="line"><span class="string">&#x27;Ajsoabk&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果不希望发生变量替换，可以把Here文档的开始标记放在单引号之中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ foo=<span class="string">&#x27;Ajsoabk&#x27;</span></span><br><span class="line">$ cat &lt;&lt; <span class="string">&#x27;_example&#x27;</span></span><br><span class="line"><span class="variable">$foo</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;$foo&#x27;</span></span><br><span class="line">_example_</span><br><span class="line"></span><br><span class="line"><span class="variable">$foo</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;$foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Here文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了<code>echo</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &lt;&lt; <span class="string">token</span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">token</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ <span class="built_in">echo</span> string |<span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p>所以，Here文档知识和哪些可以接受标准输入作为参数的命令，对于其他命令无效，比如<code>echo</code>命令就不能用Here文档作为参数</p>
<p>此外，Here文档也不能作为变量的值，只能用于命令的参数</p>
<h3 id="Here字符串"><a href="#Here字符串" class="headerlink" title="Here字符串"></a>Here字符串</h3><p>Here文档还有一个变体，叫做Here字符串，使用<code>&lt;&lt;&lt;</code>表示，它的作用是将字符串通过标准输入传递给命令</p>
<p>有些命令直接接受给定的参数与通过标准输入接受参数结果是不一样的，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;&lt; <span class="string">&#x27;hi there&#x27;</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;hi there&#x27;</span> | cat</span><br></pre></td></tr></table></figure>

<p>而如果是直接将字符串放在<code>cat</code>命令后面的话则会被解释成字符串</p>
<h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量是Bash环境自带的变量，进入Shell时已经定义好了，可以直接使用。</p>
<p>可以通过命令<code>env</code>, <code>printenv</code>来查看所有环境变量</p>
<p>下面是一些常见的环境变量</p>
<ul>
<li><p><code>BASH</code>，Shell名称，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASH=/user/bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p><code>BASH_VERSION</code>，Bash持有的shell版本，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASH_VERSION=4.2.46(2)</span><br></pre></td></tr></table></figure></li>
<li><p><code>COLUMNS</code>，屏幕的列数，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COLUMNS=80</span><br></pre></td></tr></table></figure></li>
<li><p><code>HOME</code>为用户的主目录，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOME=/home/ajsoabk</span><br></pre></td></tr></table></figure></li>
<li><p><code>LOGNAME</code>为日志的用户名，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGNAME=ajsoabk</span><br></pre></td></tr></table></figure></li>
<li><p><code>USER</code>当前用户的用户名，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER=ajsoabk</span><br></pre></td></tr></table></figure></li>
<li><p><code>LINUNO</code>返回它在脚本里面的行号</p>
</li>
<li><p><code>FUNCNAME</code>返回一个包含当前函数调用堆栈的数组</p>
</li>
<li><p><code>BASH_SOURCE</code>返回当前脚本调用堆栈</p>
</li>
<li></li>
</ul>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p> <code>set</code>命令可以显示所有变量（环境变量和自定义变量）已经所有的Bash函数</p>
<p>变量可以重复赋值，后面的赋值会覆盖前面的赋值</p>
<p>如果变量的值本身也是变量，可以使用<code>$&#123;!var&#125;</code> 的语法读取最终的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ myvar=USER</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!myvar&#125;</span></span><br><span class="line">ajsoabk</span><br></pre></td></tr></table></figure>

<h2 id="export变量"><a href="#export变量" class="headerlink" title="export变量"></a><code>export</code>变量</h2><p><code>export</code>变量能够被子Shell读取，在子Shell中更改export变量不会影响父Shell，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> foo=bar</span><br><span class="line"><span class="comment"># 新建子Shell</span></span><br><span class="line">$ bash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">bar</span><br><span class="line">$ foo=baz</span><br><span class="line"><span class="comment"># 退出子Shell</span></span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p><code>$?</code>为上一个命令的退出码，用来判断上一个命令是否执行成功，若成功则为<code>0</code>，反之则为非零值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls doesnotexist</span><br><span class="line">ls: doesnotexist: No such file or directory</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>$$</code>为当前Shell的进程ID，可以用来命令临时文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGFILE=/t,p/output_log.$$</span><br></pre></td></tr></table></figure>

<p><code>$_</code>为上一个命令的最后一个参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep dictionary /usr/share/dict/words</span><br><span class="line">dictionary</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$_</span></span><br><span class="line">/usr/share/dict/words</span><br></pre></td></tr></table></figure>

<p><code>$0</code>为当前Shell的名称或者脚本名</p>
<h3 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="变量的默认值"></a>变量的默认值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;varname:-word&#125;</span></span><br><span class="line"><span class="comment">#如果varname存在且不为空，则返回它的值，否则返回word</span></span><br><span class="line"><span class="variable">$&#123;varname:=word&#125;</span></span><br><span class="line"><span class="comment">#如果varname存在且不为空，则返回它的值，否则将它设为word并且返回word</span></span><br><span class="line"><span class="variable">$&#123;varname:+word&#125;</span></span><br><span class="line"><span class="comment">#如果varname存在且不为空，则返回word，否则返回空值</span></span><br><span class="line"><span class="variable">$&#123;varname:?word&#125;</span></span><br><span class="line"><span class="comment">#如果varname存在且不为空，则返回它的值，否则打印出varname: message，并中断脚本的执行</span></span><br><span class="line">filename=<span class="variable">$&#123;a:?&quot;filename missint.&quot;&#125;</span></span><br><span class="line"><span class="comment">#在脚本中可以用数字1到9表示传入脚本的参数</span></span><br></pre></td></tr></table></figure>

<h3 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a><code>declare</code>命令</h3><p><code>declare</code>命令可以声明一些特殊类型的变量，比如只读类型和整数类型的变量，其语法形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> OPTION VARIABLE=value</span><br></pre></td></tr></table></figure>

<p>其参数有：</p>
<ul>
<li><code>-a</code>，数组变量</li>
<li><code>-i</code>，整数变量</li>
<li><code>-r</code>，只读变量</li>
<li><code>-x</code>，环境变量</li>
<li><code>-f</code>，输出所有函数定义</li>
<li><code>-F</code>，输出所有函数名</li>
<li><code>-l</code>，变量值总是会被转为小写字母</li>
<li><code>-u</code>，变量值总是会被转为大写字母</li>
<li><code>-p</code>，输出变量信息</li>
</ul>
<p>不带任何参数的<code>declare</code>命令等同于不带任何参数的<code>set</code>命令</p>
<p><code>declare</code>命令如果用在函数中，声明的变量旨在函数内部有效，等同于<code>local</code>命令</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -i var=12</span><br><span class="line">$ var=foo</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>上面例子中，变量<code>var</code>声明为整数，覆盖以后，Bash不会报错，但会赋以不确定的值</p>
<h3 id="readonly命令"><a href="#readonly命令" class="headerlink" title="readonly命令"></a><code>readonly</code>命令</h3><p><code>readonly</code>命令等同于<code>declare -r</code>，用来声明只读变量，有三个参数</p>
<ul>
<li><code>-f</code>，声明的变量为函数名</li>
<li><code>-p</code>，打印出所有的只读变量</li>
<li><code>-a</code>，声明的变量为数组</li>
</ul>
<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a><code>let</code>命令</h3><p><code>let</code>命令声明变量时，可以直接执行算术表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">let</span> foo=1+2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><code>let</code>命令的参数表达式如果包含空格，就需要使用引用</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>命令行参数通过将数据以参数的形式传递给脚本，使脚本更具动态性，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bash_script.sh parameter1 parameter2</span><br></pre></td></tr></table></figure>

<h4 id="如何使用命令行参数"><a href="#如何使用命令行参数" class="headerlink" title="如何使用命令行参数"></a>如何使用命令行参数</h4><ul>
<li><code>$0</code>，脚本名称</li>
<li><code>$1-9</code>，存储前9个参数的名称</li>
<li><code>$#</code>，传递给脚本的参数总数</li>
<li><code>$@</code>， 以数组形式存储的参数列表</li>
<li><code>$*</code>，所有参数连接在一起后的形式</li>
</ul>
<h4 id="Shift命令与参数移位"><a href="#Shift命令与参数移位" class="headerlink" title="Shift命令与参数移位"></a>Shift命令与参数移位</h4><p><code>shift</code>命令能够控制命令行参数整体左移，同时<code>$#</code>也会减少相应个数，默认移一位，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ];<span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>可以使用<code>$&#123;#varname&#125;</code>获取字符串长度</p>
<h3 id="提取子串"><a href="#提取子串" class="headerlink" title="提取子串"></a>提取子串</h3><p>可以使用<code>$&#123;varname:offset:length&#125;</code>提取子串，可以省略<code>length</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ count=frogfootman</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;count:4:4&#125;</span></span><br><span class="line">foot</span><br></pre></td></tr></table></figure>

<p><code>offset</code>和<code>length</code>都可以为负值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ foo=<span class="string">&quot;This string is long.&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;foo: -5:2&#125;</span></span><br><span class="line">lo</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;foo: -5:-2&#125;</span></span><br><span class="line">lon</span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>length</code>为<code>-2</code>时要排除从字符串末尾开始的2个字符，所以返回<code>lon</code></p>
<h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p><code>$&#123;string#pattern&#125;</code>和<code>$&#123;string##pattern&#125;</code>可以检查字符串的<strong>开头</strong>是否匹配并将匹配的部分<strong>删除</strong>，其中前者是最短匹配，后者是最长匹配</p>
<p><code>$&#123;string/#pattern/sub&#125;</code>和<code>$&#123;string/##pattern/sub&#125;</code>可以检查字符串的<strong>开头</strong>是否匹配并将匹配的部分<strong>替换</strong>，同样的一个最短一个最长</p>
<p>将<code>#</code>换成<code>%</code>则是检查<strong>末尾</strong>，其余同上</p>
<p><code>$&#123;string/pattern/sub&#125;</code>替换第一个最长的匹配</p>
<p><code>$&#123;string//pattern/sub&#125;</code>替换所有最长匹配</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将路径分隔符：换成换行符</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="variable">$&#123;PATH//:/\\n&#x27;&#125;</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin</span><br><span class="line">/usr/bin</span><br><span class="line">/bin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h3><p><code>$&#123;string^^&#125;</code>可以把字符串转为大写</p>
<p><code>$&#123;string,,&#125;</code>可以把字符串转为小写</p>
<h2 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h2><p><code>(())</code>语法可以进行整数的算术运算，并且会自动忽略内部的空格</p>
<p>这个命令在算术结果不为<code>0</code>的时候执行成功，算术结果为<code>0</code>的时候就算执行失败</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ((3 - 3))</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>这个命令本身不返回值，如果要读取算数运算的结果，需要在第一个左括号前面加上美元符号</p>
<p>支持的算数运算符包括加减乘除、求余、递增递减、位运算、逻辑运算（包括三目运算符）、赋值运算（包括一系列复杂赋值）、逗号运算以及指数运算（<code>**</code>），注意<code>/</code>的返回结果总是整数</p>
<p><code>++</code>与<code>--</code>的前缀后缀版本的区别与C语言中相同</p>
<p>在算术表达式中可以使用其它进制</p>
<ul>
<li><code>0number</code>，八进制</li>
<li><code>0xnumber</code>，十六进制</li>
<li><code>bass#number</code>，<code>base</code> 进制的数</li>
</ul>
<h3 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a><code>expr</code>命令</h3><p><code>expr</code>命令支持算术运算，可以不使用<code>(())</code>语法</p>
<h1 id="脚本入门"><a href="#脚本入门" class="headerlink" title="脚本入门"></a>脚本入门</h1><h2 id="Shebang行"><a href="#Shebang行" class="headerlink" title="Shebang行"></a>Shebang行</h2><p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以<code>#!</code>Shebang字符开头</p>
<p>如果没有Shebang行，就只能手动将脚本传给解释器来执行</p>
<h2 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h2><h3 id="if-elif-else-fi"><a href="#if-elif-else-fi" class="headerlink" title="if[-elif-else]-fi"></a><code>if[-elif-else]-fi</code></h3><p><code>if</code>语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands...</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><code>if</code>后面可以跟任意数量的命令，这时所有命令都会执行，但是判断真伪只看最后一个命令</p>
<h3 id="case结构"><a href="#case结构" class="headerlink" title="case结构"></a><code>case</code>结构</h3><p><code>case</code>结构用于多值判断，跟包含多个<code>elif</code>的<code>if</code>结构等价，但是语义更好</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">	pattern )</span><br><span class="line">		commands ;;</span><br><span class="line">	pattern )</span><br><span class="line">		commands ;;</span><br><span class="line">	...</span><br><span class="line">	* )</span><br><span class="line">		commands ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>如果需要匹配多个条件，可以用<code>;;&amp;</code>终止每个条件块</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h3><p>格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition; <span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><code>condition</code>可以为命令</p>
<h3 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h3><p><code>until</code>循环与<code>while</code>循环恰好相反，只要不符合判断条件，就不断循环执行指定的语句，一旦符合判断条件就退出循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">until condition; <span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><code>until</code>一般用得比较少，完全可以统一使用<code>while</code></p>
<h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for...in循环"></a><code>for...in</code>循环</h3><p><code>for...in</code>循环用于遍历列表的每一项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>列表可以是以空格分隔的值（<code>for i in word1 word2 word3; do...</code>）</p>
<p>也可以由通配符产生（<code>for i in *.png; do</code>）</p>
<p>也可以通过子命令产生（<code>for i in $(cat ~/.bash_profile</code>）</p>
<p><code>in list</code>的部分可以省略，此时<code>list </code>默认等于脚本的所有参数<code>$@</code>，但是为了可读性最好还是不要省略</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( expression1; expression2; expression3 )); <span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>它等同于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(( expression1 ))</span><br><span class="line"><span class="keyword">while</span> (( expression2 )); <span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line">	(( expression3 ))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="break、continue"><a href="#break、continue" class="headerlink" title="break、continue"></a><code>break</code>、<code>continue</code></h3><p>与C中相同</p>
<h3 id="select-结构"><a href="#select-结构" class="headerlink" title="select 结构"></a><code>select</code> 结构</h3><p><code>select</code>结构用于给用户提供选择</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select element</span><br><span class="line"><span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>Bash会对<code>select</code>依次进行下面的处理</p>
<ol>
<li><code>select</code>打印一个菜单，内容是列表<code>list</code>的每一项，并且每一项前面还有一个数字编号</li>
<li>Bash提示用户选择一项，输入它的编号</li>
<li>用户输入以后，Bash会将该项的内容存在变量<code>name</code>，该项的编号存入环境变量<code>REPLY</code>。如果用户没有输入，就按回车键，Bash会重新输出菜单，让用户选择</li>
<li>执行命令体<code>commands</code></li>
<li>执行结束后回到第二步，重复这个过程</li>
</ol>
<p>下面是一个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!bin/bash</span></span><br><span class="line">select brand <span class="keyword">in</span> Samsung Sony iphone</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Youve chosen <span class="variable">$brand</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>执行上面的脚本，Bash会输出一个品牌的列表让用户选择</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) Samsung</span><br><span class="line">2) Sony</span><br><span class="line">3) iphone</span><br><span class="line"><span class="comment">#?</span></span><br></pre></td></tr></table></figure>

<p><code>select</code>可以与<code>case</code>结合</p>
<h2 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a><code>test</code>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> expression</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">[ expression ]</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure>

<p>第三种形式还支持正则判断。如果<code>expression</code>表达式为真则<code>test</code>执行成功</p>
<h3 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h3><p><code>test</code>命令有许多参数可以用来判断文件状态：</p>
<ul>
<li><code>[ -a file ]</code>，存在</li>
<li><code>[ -b file ]</code>，存在且是一个块（设备）文件</li>
<li><code>[ -c file ]</code>，存在且是一个字符（设备）文件</li>
<li><code>[ -d file ]</code>，存在且是一个目录</li>
<li><code>[ -e file ]</code>，存在</li>
<li><code>[ -f file ]</code>，存在且是普通文件</li>
<li><code>[ -g file ]</code>，存在且设置了组ID</li>
<li><code>[ -G file ]</code>，存在且设置了有效的组ID</li>
<li><code>[ -h file ]</code>，存在且是符号链接</li>
<li><code>[ -k file ]</code>，存在且设置了它的“sticky bit”</li>
<li><code>[ -L file ]</code>，存在且是符号链接</li>
<li><code>[ -N file ]</code>，存在且自上次读取后已被修改</li>
<li><code>[ -O file ]</code>，存在且属于有效的用户ID</li>
<li><code>[ -p file ]</code>，存在且是命名管道</li>
<li><code>[ -r file ]</code>，存在且当前用户可读</li>
<li><code>[ -s file ]</code>，存在且长度大于零</li>
<li><code>[ -S file ]</code>，存在且是一个socket</li>
<li><code>[ -t fd ]</code>，如果<code>fd</code>是一个文件描述符且重定向到终端则为真。可以判断是否重定向了标准输入输出/错误流</li>
<li><code>[ -u file ]</code>，存在且设置了<code>setuid</code>位</li>
<li><code>[ -w file ]</code>，存在且当前用户可写</li>
<li><code>[ -x file ]</code>，存在且当前用户可执行</li>
<li><code>[ file1 -nt file2 ]</code>，<code>file1</code>比<code>file2</code>的更新时间最近，或者<code>file1</code>存在而<code>file2</code>不存在</li>
<li><code>[ file1 -ot file2 ]</code>，<code>file2</code>比<code>file1</code>的更新时间最近，或者<code>file2</code>存在而<code>file1</code>不存在</li>
<li><code>[ FILE1 -ef FILE2 ]</code>，<code>FILE1</code>和<code>FILE2</code>引用相同的设备和<code>inode</code>编号</li>
</ul>
<h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><ul>
<li><p><code>[ string ]</code>，不为空</p>
</li>
<li><p><code>[ -n string ]</code>，不为空</p>
</li>
<li><p><code>[ -z string ]</code>，为空</p>
</li>
<li><p><code>[ string1 = string2]</code>，判断等价</p>
</li>
<li><p><code>[ string1 == string2]</code>，判断等价</p>
</li>
<li><p><code>[ string1 &#39;&gt;&#39; string2 ]</code>，判断<code>string</code>的字典序在<code>string2</code>之后</p>
</li>
<li><p><code>[ string1 &#39;&gt;&#39; string2 ]</code>，判断<code>string</code>的字典序在<code>string2</code>之前</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ str1=abc</span><br><span class="line">$ str2=abb</span><br><span class="line">$ <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> <span class="string">&#x27;&lt;&#x27;</span> <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;greater&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">greater</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="整数判断"><a href="#整数判断" class="headerlink" title="整数判断"></a>整数判断</h3><ul>
<li><code>[ -z num1 ]</code>，判断为空</li>
<li><code>[ num1 -eq num2 ]</code>，判断等价</li>
<li><code>[ num1 -ne num2 ]</code>，判断不等价</li>
<li><code>[ num1 -le num2 ]</code>，判断小于等于</li>
<li><code>[ num1 -lt num2 ]</code>，判断小于</li>
<li><code>[ num1 -ge num2 ]</code>，判断大于等于</li>
<li><code>[ num1 -gt num2 ]</code>，判断大于</li>
</ul>
<h3 id="算术判断"><a href="#算术判断" class="headerlink" title="算术判断"></a>算术判断</h3><p>可以包裹<code>(())</code>进行算术运算的判断</p>
<h3 id="正则判断"><a href="#正则判断" class="headerlink" title="正则判断"></a>正则判断</h3><p><code>[[ expression ]]</code>这种判断形式支持正则表达式</p>
<p><code> [[ string1 =~ regex ]]</code>，其中<code>=~</code>是正则比较运算符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">INT=-5</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;INT is an integer.&quot;</span></span><br><span class="line">	<span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;INT is not an integer.&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><p>可以用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>或<code>-a</code>、<code>-o</code>来结合多个<code>test</code>判断表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!bin/bash</span></span><br><span class="line">MIN_VAL=1</span><br><span class="line">MAX_VAL=100</span><br><span class="line">INT=50</span><br><span class="line"><span class="keyword">if</span> [[<span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">if</span> [[ <span class="variable">$INT</span> -ge <span class="variable">$MIN_VAL</span> &amp;&amp; <span class="variable">$INT</span> -le <span class="variable">$MAX_VAL</span> ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> is within <span class="variable">$MIN_VAL</span> to <span class="variable">$MAX_VAL</span>.&quot;</span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> is out of range.&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;INT is not an integer.&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>使用<code>!</code>操作符时，最好用圆括号确定转义的范围，并且圆括号必须使用引号或者转义，否则会被Bash解释</p>
<h2 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h2><p>调用脚本的时候，脚本文件名后面可以带有参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ script.sh word1 word2 word3</span><br></pre></td></tr></table></figure>

<p> 脚本文件内部可以使用特殊变量引用这些参数</p>
<ul>
<li><code>$1-9</code>，脚本的第一个到第九个参数</li>
<li><code>$#</code>，参数的总数</li>
<li><code>$@</code>，以数组形式存储的全部的参数</li>
<li><code>$*</code>，以<code>$IFS</code>值的第一个字符（默认为空格）分隔的全部的参数</li>
</ul>
<p>如果脚本的参数多于9个，那么第十个参数可以用<code>$&#123;10&#125;</code>的形式引用，以此类推</p>
<h3 id="shift命令"><a href="#shift命令" class="headerlink" title="shift命令"></a><code>shift</code>命令</h3><p><code>shift</code> 命令可以改变脚本参数，每次执行都会移出脚本的前几个参数（默认为1），并将后面所有的参数向前移相应位数，<code>$#</code>的值也会相应减少（如果原来有参数的话）</p>
<h3 id="getopts命令"><a href="#getopts命令" class="headerlink" title="getopts命令"></a><code>getopts</code>命令</h3><p><code>getopts</code>命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与<code>while</code>循环一起使用，去除脚本所有的带有前置<code>-</code>的参数，其形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> opt name</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>opt</code>是字符串，给出脚本所有的连词线参数（不带连词线）。</p>
<p>比如某个脚本可以有灿哥配置项参数<code>-l</code>、<code>h</code>、<code>-a</code>，其中只有<code>-a</code>可以带有参数值，而<code>-l</code>和<code>-h</code>是开关参数，那么<code>getopts</code>的第一个参数写成<code>lha:</code>，顺序不重要。注意，<code>a</code>后面有一个冒号表示该参数带有参数值</p>
<p>第二个参数<code>name</code>是一个变量名，用来保存当前取到的配置项参数，即<code>l</code>、<code>h</code>、或<code>a</code></p>
<p>以下是一个使用<code>getopts</code>获取参数的例子</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&#x27;lha:&#x27;</span> OPTION; <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;<span class="variable">$OPTION</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">		l)</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;linuxconfig&quot;</span></span><br><span class="line">			;;</span><br><span class="line">		h)</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;h stands for h&quot;</span></span><br><span class="line">			;;</span><br><span class="line">		a)</span><br><span class="line">			avalue=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;The value provided is <span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">			;;</span><br><span class="line">        ?)</span><br><span class="line">        	<span class="built_in">echo</span> <span class="string">&quot;script usage: <span class="subst">$(basename $0)</span> [-l] [-h] [-a somevalue]&quot;</span> &gt;&amp;2</span><br><span class="line">        	<span class="built_in">exit</span> 1</span><br><span class="line">        	;;</span><br><span class="line">     <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">shift</span> <span class="string">&quot;<span class="subst">$(($OPTIND - 1)</span>)&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量<code>OPTION</code>保存的是当前处理的连词线参数（即<code>l</code>、<code>h</code>或<code>a</code>）。如果用户输入了没有指定的参数，那么<code>OPTION</code>等于<code>?</code></p>
<p>如果某个连词线参数带有参数值，那么<code>$OPTARG</code>保存的就是参数值</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code>就会执行失败，从而退出<code>while</code>循环。另外，多个连词线参数写在一起的形式，比如<code>command -lh</code>，<code>getopts</code>也可以正确处理</p>
<p>变量<code>OPTIND</code>在<code>getopts</code>开始执行前是<code>1</code>，然后每次执行就会加<code>1</code>。</p>
<h3 id="配置项参数终止符"><a href="#配置项参数终止符" class="headerlink" title="配置项参数终止符--"></a>配置项参数终止符<code>--</code></h3><p><code>-</code>和<code>--</code>开头的参数，会被Bash当作配置项解释，但有时它们是实体参数，如果要确保某个参数不会被当作配置项解释，就要在它前面放上参数终止符<code>--</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -- <span class="variable">$myPath</span></span><br></pre></td></tr></table></figure>

<h3 id="exit命令"><a href="#exit命令" class="headerlink" title="exit命令"></a><code>exit</code>命令</h3><p><code>exit</code> 命令用于终止当前脚本的执行，并向Shell返回一个退出值（<code>0</code>表示正常，<code>1</code>表示发生错误，<code>2</code>表示用法不对，<code>126</code>表示不是可执行脚本，<code>127</code>表示命令没有发现</p>
<p><code>exit</code>命令与<code>return</code>命令的区别是<code>return</code>命令是函数的退出</p>
<h3 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a><code>source</code>命令</h3><p><code>source</code>命令用于执行一个脚本，但不像直接执行脚本时会新建一个子Shell，所以通常用于重新加载一个配置文件，而且<code>source</code>命令执行脚本时不需要<code>export</code>变量</p>
<p><code>source</code>命令的另一个用途，是在脚本内部加载外部库，这样就可以在脚本里面使用这个外部库定义的函数</p>
<p><code>source</code>命令有一个简写形式，可以使用一个点（<code>.</code>）来表示</p>
<h2 id="alias命令"><a href="#alias命令" class="headerlink" title="alias命令"></a><code>alias</code>命令</h2><p><code>alias</code>用于为一个命令指定一个更便于记忆的命令别名，其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> NAME=DEFINITION</span><br></pre></td></tr></table></figure>

<p>其中<code>NAME</code>是命令别名，<code>DEFINITION</code>是别名对应的原始命令，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> search=grep</span><br></pre></td></tr></table></figure>

<p>也可以用来为长命令指定一个更短的别名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> today=<span class="string">&#x27;date +&quot;%A, %B %-d, %Y&quot;&#x27;</span></span><br><span class="line">$ today</span><br><span class="line">星期日, 十一月 14, 2021</span><br></pre></td></tr></table></figure>

<p>直接调用<code>alias</code>命令可以显示所有别名</p>
<p><code>unalias</code>命令可以解除别名</p>
<h2 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h2><p><code>read</code>命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [-options] [variable...]</span><br></pre></td></tr></table></figure>

<p><code>variable</code>是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量<code>REPLY</code>会包含用户输入的一整行数据</p>
<p>如果用户的输入项少于<code>read</code>命令给出的变量数目，那么额外的变量值为空</p>
<p>如果用户的输入项多于<code>read</code>命令给出的变量数目，那么多余的输入项会包含到最后一个变量中</p>
<p><code>read</code>命令除了读取键盘输入也可以用来读入文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">filename=<span class="string">&#x27;/etc/hosts&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> myline </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$myline</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="variable">$filename</span></span><br><span class="line"><span class="comment"># 定向符&lt;将文件内容导向read命令</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>-t</code>参数设置等待的秒数，环境变量<code>TMOUT</code>也可以起到同样作用</p>
<p><code>-p</code>参数设置提示信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter one or more values &gt; &quot;</span></span><br></pre></td></tr></table></figure>

<p><code>-a</code>参数把用户的输入赋值给一个数组，下标从<code>0</code>开始：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -a people</span><br><span class="line">alice duchess dodo</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;people[2]&#125;</span></span><br><span class="line">dodo</span><br></pre></td></tr></table></figure>

<p><code>-n</code>参数指定读取字符的个数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -n 3 letter</span><br><span class="line">abcdefg</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$letter</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p><code>-e</code>参数允许用户输入的时候使用<code>readline</code>库提供的快捷键，比如自动补全</p>
<p><code>-d delimiter</code>将终止符设定为<code>delimiter</code>而不是<code>\n</code></p>
<p><code>-r</code>，raw模式，表示不把用户输入的反斜杠字符解释为转义字符</p>
<p><code>-s</code>，使用户的输入不显示在屏幕上，用于信息保密</p>
<p><code>-u fd</code>：使用文件描述符<code>fd</code>作为输入</p>
<h3 id="IFS（Internal-Field-Separator）环境变量"><a href="#IFS（Internal-Field-Separator）环境变量" class="headerlink" title="IFS（Internal Field  Separator）环境变量"></a><code>IFS</code>（Internal Field  Separator）环境变量</h3><p><code>read</code> 命令读取的值默认以空格分隔。可以通过自定义环境变量<code>IFS</code>来修改分隔标志。</p>
<p><code>IFS</code>的默认值是空格、<code>tab</code>、<code>\n</code>，通常取第一个</p>
<p>在文件读取中经常把<code>IFS</code>定义成<code>:</code>或<code>;</code></p>
<p>可以把IFS的赋值命令和<code>read</code>命令写在一行，这样的话<code>IFS</code>的改变仅对后面的命令生效，不然就要用到<code>OLD_IFS</code>变量来恢复<code>IFS</code></p>
<p>使用内置的<code>read</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter your name:&quot;</span></span><br><span class="line"><span class="built_in">read</span> user_name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$user_name</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter your age, phonenumber and email: &quot;</span></span><br><span class="line"><span class="built_in">read</span> age phonenumber email</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your age is :<span class="variable">$age</span>. Your phone is: <span class="variable">$phonenumber</span>. Your email is <span class="variable">$email</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>-p</code>参数</p>
<h2 id="Bash函数"><a href="#Bash函数" class="headerlink" title="Bash函数"></a>Bash函数</h2><p>Bash函数定义的语法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>function</code>可以省略</p>
<p>下面是一个多行函数的例子，显示当前日期时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">today</span></span>() &#123;</span><br><span class="line">	<span class="built_in">echo</span> -n <span class="string">&quot;Today&#x27;s date is: &quot;</span></span><br><span class="line">	date +<span class="string">&quot;%A, %B %-d, %Y&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除一个函数可以使用<code>unset</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> -f functionName</span><br></pre></td></tr></table></figure>

<p>查看当前Shell已经定义的所有函数的详细信息可以使用<code>declare</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -f</span><br></pre></td></tr></table></figure>

<h3 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h3><p>函数体内可以使用参数变量，与脚本参数变量是一致的</p>
<h3 id="return命令"><a href="#return命令" class="headerlink" title="return命令"></a><code>return</code>命令</h3><p><code>return</code>命令可以返回一个值给调用者。如果命令行直接执行函数，下一个命令可以用<code>$?</code>获取返回值</p>
<h3 id="local命令"><a href="#local命令" class="headerlink" title="local命令"></a><code>local</code>命令</h3><p>Bash函数体内直接声明的变量（包括函数体内声明的普通变量）都属于全局变量，整个脚本都可以读取</p>
<p>如果希望声明局部变量，需要使用<code>local</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="function"><span class="title">fn</span></span> ()&#123;</span><br><span class="line">	<span class="built_in">local</span> foo</span><br><span class="line">	foo=1</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;fn: foo = <span class="variable">$foo</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">fn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;global: foo = <span class="variable">$foo</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>其运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash test.sh</span><br><span class="line">fn: foo = 1</span><br><span class="line">global: foo =</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个包含多个值的变量，成员的编号从0开始</p>
<p>数组可以采用一次性赋值的方式创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array=(val1 val2 ... valn)</span><br><span class="line"><span class="comment"># 也可以</span></span><br><span class="line">array[0]=val1</span><br><span class="line">array[1]=val2</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 也可以</span></span><br><span class="line">array=([2]=val3 [0]=val1 [1]=val2)</span><br><span class="line"><span class="comment">#也可以只为某些值指定位置</span></span><br><span class="line">names=(hater [5]=duchess alice)</span><br><span class="line"><span class="comment">#上面例子中alice是6号位</span></span><br></pre></td></tr></table></figure>

<h3 id="成员读取"><a href="#成员读取" class="headerlink" title="成员读取"></a>成员读取</h3><p>数组的成员读取方式为<code>$&#123;arr[n]&#125;</code>。如果没有花括号，Bash会读取<code>arr</code>的第一个元素，再把<code>[n]</code>原样输出</p>
<p>可以用<code>$&#123;arr[@]&#125;</code>和<code>$&#123;arr[*]&#125;</code>获取数组的所有成员</p>
<p>将其放在双引号中时，后者会将数组元素合并成一个字符串返回</p>
<p>所以拷贝一个数组的最方便方法就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hobbies=( <span class="string">&quot;<span class="variable">$&#123;activities[@]&#125;</span>&quot;</span> )</span><br></pre></td></tr></table></figure>

<h3 id="提取数组序号"><a href="#提取数组序号" class="headerlink" title="提取数组序号"></a>提取数组序号</h3><p><code>$&#123;!arr[@]&#125;</code>或<code>$&#123;!arr[*]&#125;</code>可以返回数组的成员序号</p>
<p>因此可以使用这种语法循环数组的下标</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr=(a b c d)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;!arr[@]&#125;</span>;<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;arr[i]&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="提取数组成员"><a href="#提取数组成员" class="headerlink" title="提取数组成员"></a>提取数组成员</h3><p><code>$&#123;arr[@]:pos:len&#125;</code>的语法可以提取一个区间内的成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ food=( apples bananas cucunmbers dates eggs fajitas grapes )</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;food[@]:1:3&#125;</span></span><br><span class="line">bananas cucumbers dates</span><br></pre></td></tr></table></figure>

<p>如果省略<code>length</code>则返回从指定位置开始的所有成员</p>
<h3 id="追加数组成员"><a href="#追加数组成员" class="headerlink" title="追加数组成员"></a>追加数组成员</h3><p>可以使用<code>+=</code>赋值运算符追加数组成员</p>
<h3 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h3><p>使用<code>unset</code>命令删除数组或数组成员</p>
<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><p><code>declare -A</code>可以声明关联数组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delcare -A colors </span><br><span class="line">colors[<span class="string">&quot;red&quot;</span>]=<span class="string">&quot;#ff0000&quot;</span></span><br><span class="line">colors[<span class="string">&quot;green&quot;</span>]=<span class="string">&quot;#00ff00&quot;</span></span><br></pre></td></tr></table></figure>

<p>访问关联数组成员的方法几乎与整数索引数组相同</p>
<h2 id="set命令与shopt命令"><a href="#set命令与shopt命令" class="headerlink" title="set命令与shopt命令"></a><code>set</code>命令与<code>shopt</code>命令</h2><p><code>set</code>命令可以帮助你写出更安全的Bash脚本</p>
<p>直接运行<code>set</code>会显示所有的环境变量和Shell函数</p>
<h3 id="u"><a href="#u" class="headerlink" title="-u"></a><code>-u</code></h3><p>设置了<code>-u</code>参数之后，脚本遇到不存在的变量就会报错并停止执行</p>
<p><code>-u</code>参数和<code>-o nounset</code>是等价的</p>
<h3 id="x"><a href="#x" class="headerlink" title="-x"></a><code>-x</code></h3><p>设置了<code>-x</code>参数之后，脚本每运行一条命令就会在终端输出，用于调试，与<code>-o xtrace</code>等价</p>
<p>如果要关闭命令输出，可以使用<code>set +x</code></p>
<h3 id="e"><a href="#e" class="headerlink" title="-e"></a><code>-e</code></h3><p>设置了<code>-e</code>参数之后，脚本只要发生错误（返回值非<code>0</code>），就会终止执行</p>
<p>有些命令的非零返回值可能不表示失败，这时可以使用<code>command || true</code>使得该命令即使执行失败也不会终止执行</p>
<p>等价于<code>-o errexit</code></p>
<h3 id="o-pipefail"><a href="#o-pipefail" class="headerlink" title="-o pipefail"></a><code>-o pipefail</code></h3><p><code>set -e</code>不适用于管道命令</p>
<p>管道命令指多个子命令通过管道运算符<code>|</code>组合成一个大的命令。Bash会把最后一个子命令的返回值作为整个命令的返回值。</p>
<p><code>set -o pipefail</code>用来保证只要一个子命令失败整个管道命令就失败</p>
<h3 id="E"><a href="#E" class="headerlink" title="-E"></a><code>-E</code></h3><p>设置了<code>-e</code>参数会导致函数内的错误不会被<code>trap</code>命令捕获，加上<code>-E</code>参数后可以使得函数也能继承<code>trap</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -Eeuo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo ERR trap fired!&quot;</span> ERR</span><br><span class="line"><span class="function"><span class="title">myfunc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># &#x27;foo&#x27;是一个不存在的命令</span></span><br><span class="line">	foo</span><br><span class="line">&#125;</span><br><span class="line">myfunc</span><br></pre></td></tr></table></figure>

<p>执行上面这个脚本就可以看到<code>trap</code>命令生效了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash test.sh</span><br><span class="line">test.sh:行9: foo：未找到命令</span><br><span class="line">ERR <span class="built_in">trap</span> fired!</span><br></pre></td></tr></table></figure>

<h3 id="n"><a href="#n" class="headerlink" title="-n"></a><code>-n</code></h3><p>等同于<code>-o noexec</code>不运行命令，只检查语法是否正确</p>
<h3 id="f"><a href="#f" class="headerlink" title="-f"></a><code>-f</code></h3><p>等同于<code>-o noglob</code>表示不对通配符进行文件名拓展</p>
<h3 id="v"><a href="#v" class="headerlink" title="-v"></a><code>-v</code></h3><p>等同于<code>-o verbose</code>，表示打印Shell接收到的每一行输入</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍的<code>set</code>命令的几个参数，一般都放在一起使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -Eeuxo pipefail</span><br></pre></td></tr></table></figure>

<p>这种写法建议放在所有Bash脚本的头部</p>
<p>另一种方法是在执行Bash脚本的时候，从命令行传入这些参数</p>
<h3 id="shopt命令-1"><a href="#shopt命令-1" class="headerlink" title="shopt命令"></a><code>shopt</code>命令</h3><p><code>shopt</code>命令用来调整Shell 的参数，跟<code>set</code>命令的作用类似</p>
<p>直接输入<code>shopt</code>可以查看所有参数以及其状态，也可以单独查询某个参数的状态</p>
<p><code>-s</code>用来打开某个参数</p>
<p><code>-u</code>用来关闭某个参数</p>
<p><code>-q</code>也用来查询某个参数是否打开，但不直接输出查询结果，而是通过<code>shopt</code>命令的返回结果<code>$?</code>表示查询结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -1 globstar</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="mktemp与trap"><a href="#mktemp与trap" class="headerlink" title="mktemp与trap"></a><code>mktemp</code>与<code>trap</code></h3><p>Bash脚本有时需要创建临时文件或临时目录，常见的做法是在<code>/tmp</code>目录里面创建文件或目录，但这样做有很多问题，使用<code>mktemp</code>命令是最安全的做法</p>
<h3 id="临时文件的安全问题"><a href="#临时文件的安全问题" class="headerlink" title="临时文件的安全问题"></a>临时文件的安全问题</h3><p><code>/tmp</code>目录是所有人可读写的，如果攻击者知道临时文件的文件名就可能导致严重的安全问题。</p>
<p>而且脚本意外退出时往往会糊涂清理临时文件</p>
<p>生成临时文件淫应当遵循下面的规则</p>
<ul>
<li>创建前检查文件是否已经存在</li>
<li>确保临时文件已成功创建</li>
<li>临时文件必须有权限限制</li>
<li>临时文件名要不可预测</li>
<li>脚本退出时要删除临时文件</li>
</ul>
<h3 id="mktemp"><a href="#mktemp" class="headerlink" title="mktemp"></a><code>mktemp</code></h3><p>直接运行<code>mktemp</code>命令就能生成一个临时文件，其文件名随机并且只有用户本人可读写</p>
<p>为了保证脚本退出时临时文件被删除，可以使用<code>trap</code>命令指定退出时的清除操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;rm -f &quot;$TMPFILE&quot;&#x27;</span> EXIT</span><br><span class="line">TMPFILE=$(mktemp) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Our temp file is <span class="variable">$TMPFILE</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>-d</code>参数可以创建一个临时目录</p>
<p><code>-p</code>参数可以指定临时文件所在的目录，默认使用<code>$TMPDIR</code>环境变量指定的目录，如果这个变量没设置则使用<code>/tmp</code>目录</p>
<p><code>-t</code>参数可以指定临时文件的文件名模板，模板末尾至少包含索格连续的<code>X</code>字符表示随机字符，默认的文件名模板是<code>tmp.</code>后接十个随机字符</p>
<h3 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a><code>trap</code>命令</h3><p><code>trap</code>命令用来在Bash脚本响应系统信号，其形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> [action] [signal1] [signal2] ...</span><br></pre></td></tr></table></figure>

<p>其中<code>action</code>是一个Bash命令，常用的信号有</p>
<ul>
<li><code>EXIT</code>，编号<code>0</code>，退出脚本时产生</li>
<li><code>HUP</code>，编号<code>1</code>，脚本与所在的终端脱离联系</li>
<li><code>INT</code>，编号<code>2</code>，用户按下<code>ctrl + C</code>，意图让脚本停止运行</li>
<li><code>QUIT</code>，编号<code>3</code>，用户按下<code>ctrl+/</code>，意图退出脚本</li>
</ul>
<p>注意，<code>trap</code>命令必须放在脚本的开头，否则它上方的任何命令导致脚本退出，都不会被它捕获</p>
<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p>可以通过<code>ls -l</code>命令来罗列出所有文件和目录</p>
<p><img src="https://atts.w3cschool.cn/attachments/image/20200616/1592287146504129.png" alt="img"></p>
<p>上图七列分别是：</p>
<ul>
<li>文件类型（<code>-</code>常规文件，<code>c</code>特殊档案，<code>p</code>命名管道，<code>b</code>块设备，<code>s</code>套接字，<code>d</code>目录，<code>l</code>链接）及超级用户、用户组与其他用户的权限（<code>r</code>阅读权限，<code>w</code>写入权限，<code>x</code>执行权限，<code>-</code>占位）</li>
<li>存储块的数量</li>
<li>文件的所有者或具有管理权限的超级用户</li>
<li>所有者、筹集用户组</li>
<li>文件大小</li>
<li>文件的最后修改日期</li>
<li>文件或目录的名称</li>
</ul>
<p><code>chmod</code>命令可以更改不同用户类型的文件权限，其基本形式为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod [class][operator][permission] filename</span><br><span class="line"><span class="comment">#具体为</span></span><br><span class="line">chmod [ugoa][+or-][rwx] filename</span><br></pre></td></tr></table></figure>

<p><code>u</code>超级用户<code>g</code>用户组<code>o</code>其他用户<code>a</code>所有类型</p>
<p><code>+</code>添加<code>-</code>删除权限</p>
<p><code>r</code>读取<code>w</code>修改<code>x</code>运行</p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p><code>&gt;</code>会以命令中的写入内容覆盖原文件内容，如果指定的文件不存在，那么它将会创建一个以指定文件名命名的新文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">writefile=WriteFile.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Ajsoabk:www.ajsoabk.xyz&quot;</span> &gt; <span class="variable">$writefile</span></span><br><span class="line"><span class="comment">#使用cat命令打印文件内容</span></span><br><span class="line">$ cat <span class="variable">$writefile</span></span><br></pre></td></tr></table></figure>

<p><code>&gt;&gt;</code>则是内容附加，如果文件不存在也会新建</p>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p><code>&lt;</code>,与<code>&lt;&lt;</code></p>
<h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><ul>
<li><code>stdin</code>：标准输入文件，其文件描述符为0，默认由此读取数据</li>
<li><code>stdout</code>：标准输出文件，其文件描述符为1，默认向它输出数据</li>
<li><code>stderr</code>：标准错误文件，其文件描述符为2，默认向它写入错误信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将stdin重定向到file1，将stdout重定向到file2</span></span><br><span class="line">$ <span class="built_in">command</span> &lt; file1 &gt; file2</span><br></pre></td></tr></table></figure>



<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p>过于简单：<code>cd</code>，<code>mkdir</code>,<code>stat</code>，<code>rmdir</code>, <code>rm</code>(删除目录或文件）</p>
<p><code>touch</code>命令可以用来修改文件读取时间和修改时间，<code>-t</code>参数自定义修改时间</p>
<p><img src="https://i.bmp.ovh/imgs/2021/11/c29ad154f64a600c.png"></p>
<h2 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h2><p><code>cat</code>的全拼是concatenate，主要有三大功能</p>
<h3 id="显示整个文件"><a href="#显示整个文件" class="headerlink" title="显示整个文件"></a>显示整个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> filename</span><br></pre></td></tr></table></figure>

<h3 id="从键盘创建新文件"><a href="#从键盘创建新文件" class="headerlink" title="从键盘创建新文件"></a>从键盘创建新文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将stdout重定向到filename</span></span><br><span class="line"><span class="variable">$cat</span> &gt; filename</span><br></pre></td></tr></table></figure>

<h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> file1 file2 &gt; file</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>-n</code>or<code>-number</code>输出带行数</li>
<li><code>-b</code>or<code>-number-nonblank</code>，输出带行数，但对空行不编号</li>
<li><code>-s</code>or<code>-squeeze-blank</code>，当遇到有两行以上的空行，压缩为一行空行</li>
<li><code>-v</code>or<code>-show-nonprinting</code>， </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/06/%E8%AF%BB%E8%AE%BA%E6%96%87%E4%B9%8B%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C-%E9%AB%98%E5%AE%B9%E9%87%8F%E9%93%BE%E4%B8%8B%E5%8D%B3%E6%97%B6%E6%94%AF%E4%BB%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/06/%E8%AF%BB%E8%AE%BA%E6%96%87%E4%B9%8B%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C-%E9%AB%98%E5%AE%B9%E9%87%8F%E9%93%BE%E4%B8%8B%E5%8D%B3%E6%97%B6%E6%94%AF%E4%BB%98/" class="post-title-link" itemprop="url">读论文之闪电网络-可扩容链下即时支付系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-06 16:09:34 / 修改时间：17:08:53" itemprop="dateCreated datePublished" datetime="2021-11-06T16:09:34+08:00">2021-11-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://lightning.network/lightning-network-paper.pdf">闪电网络-可扩容链下即时支付系统</a></p>
<h2 id="The-Bitcoin-Blockchain-Scalability-Problem"><a href="#The-Bitcoin-Blockchain-Scalability-Problem" class="headerlink" title="The Bitcoin Blockchain Scalability Problem"></a>The Bitcoin Blockchain Scalability Problem</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/05/%E8%AF%BB%E8%AE%BA%E6%96%87%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81-%E4%B8%80%E7%A7%8D%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9A%84%E7%94%B5%E5%AD%90%E7%8E%B0%E9%87%91%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/05/%E8%AF%BB%E8%AE%BA%E6%96%87%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81-%E4%B8%80%E7%A7%8D%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9A%84%E7%94%B5%E5%AD%90%E7%8E%B0%E9%87%91%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">读论文之比特币-一种点对点的电子现金系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-05 19:59:47" itemprop="dateCreated datePublished" datetime="2021-11-05T19:59:47+08:00">2021-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-06 16:54:02" itemprop="dateModified" datetime="2021-11-06T16:54:02+08:00">2021-11-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> <a target="_blank" rel="noopener" href="https://bitcoin.org/bitcoin.pdf">比特币：一种点对点的电子现金系统</a></p>
<p>比特币的经典文章必须好好研读一下</p>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>转出者将该币的前一个交易地址与转入者的公钥打包后签名</p>
<p>首要的问题当然是转入者没法验证转出者是否双花，传统的解决方法是让可信任的权威机构或银行来检查每笔交易以防止双花，每笔交易的币都需要由转出者给到银行、再由银行给到转入者。这一方法的问题是整个系统都高度依赖于中央银行。</p>
<p>我们需要让转入者能独立验证交易的合法性，这要求转入者知道所有的交易信息，因此每笔交易都需要在网络上公开。我们还需要让所有参与这笔交易的人对这笔钱的历史交易信息有共识。转出者需要让每笔交易都能被大部分节点承认。</p>
<h2 id="timestamp-server"><a href="#timestamp-server" class="headerlink" title="timestamp server"></a>timestamp server</h2><p>timestamp server记录一系列的包含时间戳的区块并将其哈希值广泛公开。每个时间戳都包含了前一个区块的哈希值。在这样的一条链上，每加入一个新区块都会巩固前面的区块</p>
<h2 id="Proof-of-Work"><a href="#Proof-of-Work" class="headerlink" title="Proof-of-Work"></a>Proof-of-Work</h2><p>为了在点对点的基础上实现这样的分布式timestamp server，我们需要使用工作量证明（Pow）机制。工作量证明机制需要通过枚举找到一个值，这个值在被某些哈希算法转换后（如SHA-256）得到的哈希值以数个连续的零开头。找这个值所需要的时间与零值的个数要求呈指数关系。但一旦找到，其他节点验证这个值的合法性则很快。（跑一遍SHA-256即可）</p>
<p>在这样的一个时间戳网络内，我们不断枚举nonce值直到这个区块的哈希值以一连串符合要求的0值开头。有了这样的算力投入，要想篡改区块就必须付出同等的代价。由于后面的区块包含了前面区块的哈希，因此篡改单个区块后还需要篡改其后面的所有区块。</p>
<p>Pow机制帮助大家形成对代表的共识。如果每个IP地址都有一个投票权（<strong>one-IP-address-one-vote</strong>)，那么投票肯定会被购买了大量IP地址的人所操控。Pow本质上是（<strong>one-CPU-one-vote</strong>)。系统中的最长链就是大家的共识，大家在这条链上投入了最多的算力。只要主要的算力由诚实节点所控制，那么合法的链条就一定会增长得最快。为了修改一个过去的区块，攻击者必须投入该区块以及其后所有区块上曾被投入的算力，并且必须赶超诚实节点所维护的最长合法链。我们将稍后展示一个稍慢一步的攻击者（指没来得及挖出最新区块）追上最长合法链的可能性将随着后续区块的增加指数下降</p>
<p>为了适应增长迅速的硬件处理速度和随时间变化的挖矿收益，挖矿难度是随过去一段时间内每小时挖出区块的平均值决定的。如果区块产生的速度过快，挖矿难度将自动升高</p>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>这个网络的运行有以下步骤：</p>
<ol>
<li>给所有节点广播新的交易信息</li>
<li>每个节点将自己收到的交易信息放进区块中</li>
<li>每个节点投入算力来找到符合工作量证明难度的哈希值（挖矿）</li>
<li>当一个节点挖到了矿，它将其广播给其他所有节点</li>
<li>只有一个区块内的所有交易都是合法且有效的时候，节点才会认为这个区块合法并承认它</li>
<li>一个节点承认一个区块的表现是它在这个区块后挖矿</li>
</ol>
<p>节点总是承认最长合法链并一直投入算力来延长它。如果两个节点同时广播了两个不同的区块，其他节点分别会率先接收到其中一个。这样的话，这些节点就会在自己第一个接收到的区块后挖矿，这样的平衡不会维持很久，因为总会有新的区块被率先挖出来，这样的话其中一个分支就会变得更长，工作在更短分支上的节点也会立刻转入新的最长合法链</p>
<p>新的交易信息不需要直接发送到所有节点。只要它被发送到了足够多的节点，这些信息很快就会被写入区块。这样的广播也能适应丢失消息的情况。如果一个节点没有接收到某个区块，在接收到下一个区块的时候它会发现自己少接收了一个</p>
<h2 id="Incentive"><a href="#Incentive" class="headerlink" title="Incentive"></a>Incentive</h2><p>按照惯例，区块内的第一笔交易是一笔铸币交易，给新区块的创造者发行了新的币。这样的设计能给节点更大动力来维持比特币网络的运行，并且提供了一种发行货币并流通的方式，这样不需要任何中央机构就能发行新的比特币了</p>
<p>交易费同样也是动力之一。如果一笔交易的输出小于输入，其差额就是支付给区块挖出者的交易费。只要一个预先确定的定量金额的比特币进入了市场，挖矿的动力就完全转换成了交易费，系统也就不会再有通胀了</p>
<h2 id="Reclaiming-Disk-Space"><a href="#Reclaiming-Disk-Space" class="headerlink" title="Reclaiming Disk Space"></a>Reclaiming Disk Space</h2><p>只要一个币的最近一次交易被写入了足够多的区块，为了节约磁盘空间，在其之前的交易信息就可以被抛弃。为了尽量节约空间而不打破区块的哈希，交易将被以哈希形式存储在默克尔树上，只有根哈希被包含进了区块头的哈希。过去的区块能通过将除了根哈希外的所有分支都除去从而大大节约磁盘空间，因为这些分支上的哈希都没有存储的必要</p>
<p>一个不包含具体交易信息的区块头大约是80字节。我们假设每十分钟挖出一个区块，80 bytes * 6 * 24 * 365 = 4.2MB/year。2008年的计算机基本都有2GB的内存，并且摩尔定律预测现在的增长速度可能是1.2GB/year，因而就算区块头必须被放在内存中，也并没有存储问题</p>
<h2 id="Simplified-Payment-Verification"><a href="#Simplified-Payment-Verification" class="headerlink" title="Simplified Payment Verification"></a>Simplified Payment Verification</h2><p> 不运行一个全节点也是可以验证交易合法性的。一个用户只需要通过询问网络中的其他节点来获得最长合法链的所有区块头，并且获得这个交易所在的默克尔树的区块及其路径。用户不能自己检查交易是否正确，但只要这个区块后接了足够多的区块，他就能确定整个网络承认了这个交易</p>
<p>实际上，只要诚实节点控制着网络，这样的验证就是可信赖的，但如果恶意节点掌控了整个网络，它就会变得很脆弱。网络上的节点可以自己验证交易合法性，但只要攻击者一直掌控着网络，上面这种简化的验证过程则很容易被攻击者所伪造的交易信息所欺骗。对抗攻击者的其中一个策略是从网络上其他节点中接收警报，这驱使用户的软件下载下全节点的信息以及危险的交易来确认警报。一些经常处理交易的公司可能会想运行自己的全节点来保证独立性和安全性，还能保证更快的验证</p>
<h2 id="Combining-and-Splitting-Value"><a href="#Combining-and-Splitting-Value" class="headerlink" title="Combining and Splitting Value"></a>Combining and Splitting Value</h2><p>尽管控制单个币的流动是可行的，但在交易中写明每个币的流向将会很累赘。为了让价值能够被拆分与合并，每笔交易都能包含多个输入与输出。一般情况下既可以让一笔大交易的输出成为当前交易的唯一输入，也可以让多笔小交易的输出成为当前交易的多个输入。最多只能有两个输出，一个用于支付，另一个用于返还，如果需要的话，返还给转出者</p>
<p>需要注意的是依赖于之前多笔交易的扇入过程并不麻烦，因为不需要将前向交易的完整信息复制到当前交易中来</p>
<h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>传统的银行模式通过限制人们获取其他人的信息来实现某种程度的隐私保护。由于比特币网络天然需要公开所有交易，因而这样的方法无法复用，但是隐私仍然可以通过打破信息在某个地方的流通来实现保护：保持公钥的匿名性。公众能看到某个节点给另一个节点转了帐，但不能将这笔交易联系到任何具体的人身上。这有点像股票交易的信息流通方式-每笔买入或卖出的时间与数额都是公开的，但不能得知是谁进行了这样的交易</p>
<p>除此之外，每笔交易都可以通过引入新的公私钥对来防止某些交易跟一个共同的拥有者相联系。在一些扇入交易中有些联系仍然是不可避免的，因为这会揭示这些输入的交易所在节点被同一个人所拥有。其中的风险在于如果某人与其公钥对应起来了，这样的联系会告诉我们其他的很多交易也是属于同一个拥有者的</p>
<h2 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h2><p>数学证明略。。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/04/RSA%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/04/RSA%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">RSA学习与思考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-04 21:35:49" itemprop="dateCreated datePublished" datetime="2021-11-04T21:35:49+08:00">2021-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 16:30:56" itemprop="dateModified" datetime="2021-11-05T16:30:56+08:00">2021-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p><strong>RSA加密算法</strong>是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的</p>
<p>​                                                                                                ————————-Wikipedia</p>
</blockquote>
<p>RSA是一种非常广泛使用的<strong>非对称加密算法</strong>，如其名，这种算法首先是一种加密算法。加密算法可不止是加密，而是包括密钥准备、加密、解密等等全过程的一种算法。那么加密解密为何如此重要呢？</p>
<p>在网络上，信息是可以完美复制的，节点与节点在信号发送上没有区别，这就导致了一个问题，<strong>我怎么知道某段冷冰冰的01信号是谁发给我的？</strong>同样的，由于信号传递过程中难免要经过其他节点，<strong>如果我不想让其他节点知道我发送的信息我又要怎么办呢？</strong></p>
<p>这些问题就可以通过理想的公私钥加密体系完美解决。公钥私钥的区别只在于是否公开，而两者都可以用来加密，只是用公钥加密后的信息只能被私钥解密，被私钥加密后的信息也只能被公钥解密。这就对应了上面两个问题的解决方法。</p>
<p>首先，公钥完全公开透明，每个人都可以用公钥加密，但是产生的密文却只有私钥才能解密成明文，这样保证了有用情报只会被拥有私钥的人接收，我们就能把信息发给拥有私钥的那个人而不用担心被别人得知了。</p>
<p>反过来呢？拥有私钥的人对某段信息用私钥加密之后，产生的密文能被所有人解密成明文，这样又有什么效果呢？为了把明文和无效信息区分开来，假设我们约定了明文中至少要包含的有效信息（比如发布时间等等），那么密文就与加密者产生了对应关系，我们只需用加密者发布的公钥做一下解密，再验证一下明文中是否有这些有效信息，就能确认这段信息是不是由私钥拥有者发布的了。这样信息就有了归属，我们就能确认某段信息是我们想要的人发给我们的了。而这种私钥加密的过程也称为<strong>签名</strong>。</p>
<h2 id="“非对称”并非核心"><a href="#“非对称”并非核心" class="headerlink" title="“非对称”并非核心"></a>“非对称”并非核心</h2><p>“ 非对称加密 ”本身没什么厉害的，我们可以随便设计一个非对称的加密算法，就让乘私钥作为加密，乘公钥作为解密，那么整个原理就是<code>message * privatekey * publickey = message</code>，在这里，公钥与私钥的对应关系就是<code>privatekey = 1 / publickey</code>。你应该能发现，这样的加密解密似乎没啥保密性可言，任何学过小学数学的人都能很快地从公钥推出私钥，也就能随意冒充你来发布消息了。因此，“似乎”保证私钥与公钥难以互相推导是非常重要的</p>
<p>不能让公钥简单推到私钥是显然的，但为什么说也不能让私钥简单推到公钥呢？这里我们要明确一点，公钥与私钥只是互成一对，并没有形式上的区别，我既能用公钥加密，也能用私钥加密。那如果算法保证了只知道公钥的时候难以推出私钥的话，反过来也是一样的。在<strong>只知道私钥</strong>的情况下也难以推出公钥，注意！是<strong>只知道私钥</strong>！而生成这一对公私钥的过程中是产生了很多过程变量的，这些过程变量才是算法生成公私钥对的某种依据</p>
<p>总结来说，RSA等一众非对称加密算法通过某个数学过程产生了互成一对但难以相互推导的公钥与私钥，然后大家就能愉快地用公私钥来在网络上加密通信了。</p>
<h1 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h1><p>求余，一个小学就接触到的数学运算，那时候我们把除法得到的整数后加几个点，再接上一个数表示余数:</p>
<p>$$ 5 \div 3 = 1 \dots 2$$</p>
<p>这样的写法中，余数表现得就像它的名字一样——有点多余。当时的我们可没想到，这么简单的一个余数及其相关的运算，竟然能在数论中爆发出那么强大的力量</p>
<p>废话少说，让我们再多多观察观察这个运算，为了不考虑向下取整与向0取整，我们忽略负数的情况</p>
<p>在上面的例子中，如果我们不关注商而只关注余数，那么包括2、5、8等等在内的一系列数对3求余结果都是2，包括1、4、7在内的一系列数对3求余结果都是1，类似的，如果我们只关注整数n对m求余后的结果，那么所有的n就能根据这个结果分成m个集合，我们把这样划分后在同一个集合内的两个数称为<strong>模m同余</strong>，这样的集合称为<strong>同余类</strong>，求余运算的新形式也就这么出现了</p>
<blockquote>
<p>两个整数a,b，若它们除以正整数m所得的余数相等，则称a，b对于模数m同余，记作:$$a \equiv b\ (\ mod\ m)$$</p>
</blockquote>
<p>对于一个运算符，最重要的概念是什么？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/04/%E5%8D%95%E8%AF%8D%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/04/%E5%8D%95%E8%AF%8D%E6%9C%AC/" class="post-title-link" itemprop="url">单词本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-04 18:49:53" itemprop="dateCreated datePublished" datetime="2021-11-04T18:49:53+08:00">2021-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-18 14:48:20" itemprop="dateModified" datetime="2021-11-18T14:48:20+08:00">2021-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>overlapping, substantial, redundancy, predicate, mediate, hassle, mint, inflation, lunge, compact, broadband, a.k.a., in volume, micropayment, malleability, scalability, ledger, refactor, </p>
<ol>
<li><p><strong>pharmaceutical</strong>, relating to the production of medicines.</p>
</li>
<li><p><strong>dues</strong>, the official payments that you make to an organization you belong to</p>
</li>
<li><p><strong>evasion</strong>, the act of avoiding something or someone</p>
<p>eg: tax evasion</p>
</li>
<li><p><strong>ballot</strong>, a piece of paper on which you write your vote</p>
</li>
<li><p><strong>implement</strong>, to put a plan into action</p>
</li>
<li><p><strong>slip</strong>,a small piece of paper</p>
</li>
<li><p><strong>reminiscent</strong> -&gt; <strong>reminiscent of sb/sth</strong>, making you remember a particular person, event, or thing.</p>
<p>eg: That song is so reminiscent of my adolescence</p>
</li>
<li><p><strong>debit</strong>, (a record of ) money taken out of a bank account</p>
</li>
<li><p><strong>mediate</strong>, to talk to two separate people or groups involved in a disagreement to </p>
</li>
<li><p><strong>escrow</strong>, an agreement between two people or organization in which money or property is kept by a third person or organization until a particular condition is met</p>
</li>
<li><p><strong>subvert</strong>, to try to destroy or damage something, especially an established political system</p>
</li>
<li><p><strong>analogous</strong>, having similar features to another thing and therefore able to be compared with it</p>
<p>eg: The emergency vehicle for the International Space Station is analogous to a lifeboat</p>
</li>
<li><p><strong>preclude</strong>, to prevent something or make it impossible, or prevent someone from doing something.</p>
</li>
<li><p><strong>deficit</strong>, the total amount by which money spent is more than money received.</p>
</li>
<li><p><strong>issue</strong>, to produce or provide something official.</p>
</li>
<li><p><strong>encompass</strong>, to include different types of things.</p>
</li>
<li><p><strong>custodial</strong>, referring to or having the responsibility of protecting, caring for, or maintaining something or someone.</p>
</li>
<li><p><strong>ubiquitous</strong>, seeming to be everywhere</p>
</li>
<li><p><strong>indicator</strong>, something that shows what a situation is like</p>
</li>
<li><p><strong>ecology</strong>, the relationships between the air, land, water, animals, plants, etc., usually of a particular area.</p>
</li>
<li><p><strong>proliferate</strong>, to increase a lot and suddenly in number</p>
</li>
<li><p><strong>actuate</strong>, to make a machine work or be the reason a person acts in a certain way.</p>
</li>
<li><p><strong>altruism</strong>, willingness to do things that bring advantages to others, even if it results in disadvantage for yourself.</p>
</li>
<li><p><strong>seamlessly</strong>, without any sudden changes, interruptions, or problems.</p>
</li>
<li><p><strong>-centric</strong>, having a particular type of person, place, or thing as your most important interest; seen from the point of view of a particular type of person, place, or thing.</p>
</li>
<li><p><strong>paradigm</strong>, a model of something, or a very clear and typical example of something.</p>
</li>
<li><p><strong>commodity</strong>, a substance or product that can be traded, bought, or sold.</p>
</li>
<li><p><strong>utility</strong>, able to do several different things well.</p>
</li>
<li><p><strong>pervasive</strong>, present or noticeable in every part of a thing or place.</p>
</li>
<li><p><strong>intervention</strong>, the action of becoming intentionally involved in a difficult situation, in order to improve it or prevent it from getting worse.</p>
</li>
<li><p><strong>verge</strong>, the edge or border of something<br>eg: They set up camp on the verge of the desert</p>
</li>
<li><p><strong>daemon</strong>, background processes that worked tirelessly to perform system chores</p>
</li>
<li><p><strong>ventilator</strong>, a machine that helps people breathe when they have difficulty breathing on their own, by forcing air in and out of their lungs.</p>
</li>
<li><p><strong>avionics</strong>, the electronic devices of an aircraft or spacecraft</p>
</li>
<li><p><strong>telemetry</strong>, the science or process of collecting information about objects that are for away and sending the information somewhere electronically</p>
</li>
<li><p><strong>rocketry</strong>, the design and construction of rockets</p>
</li>
<li><p><strong>intermittent</strong>, not happening regularly or continuously; stopping and starting repeatedly or with periods in between</p>
</li>
<li><p><strong>erratic</strong>, moving or behaving in a way that is not regular, certain, or expected.</p>
</li>
<li><p><strong>afflict</strong>, if a problem or illness  afflicts a person or thing, they suffer from it.</p>
</li>
<li><p><strong>mitigate</strong>, to make something less armful, unpleasant, or bad.</p>
</li>
<li><p><strong>destabilizing</strong>, making a government, area, or political group lose power or control, or making a political or economic situation less strong or safe, by causing changes and problems.</p>
</li>
<li><p><strong>malicious</strong>, intended to harm or upset other people.</p>
</li>
<li><p><strong>exploitable</strong>, able to be used unfairly, for someone’s own advantage.</p>
</li>
<li><p><strong>snippet</strong>, a small and often interesting piece of news, information, or conversation.</p>
</li>
<li><p><strong>undue</strong>, to a level that is more than is necessary, acceptable, or reasonable.<br>eg: Such a high increase will impose an undue burden on the local tax payer.</p>
</li>
<li><p><strong>glean</strong>, to collect information in small amounts and often with difficulty<br>eg: They’re leaving on Tuesday - I managed to glean that much (from them)</p>
</li>
<li><p><strong>esoteric</strong>, very unusual and understood or liked by only a small number of people, especially those with special knowledge.</p>
</li>
<li><p><strong>de facto</strong>, /dei…/, existing in fact, although perhaps not intended, legal, or accepted.</p>
</li>
<li><p><strong>imbue sth./sb. with sth.</strong>, to fill something or someone with a quality or feeling.<br>eg: Her poetry was imbued with a love of the outdoors.</p>
</li>
<li><p><strong>intercept</strong>, to stop or catch something or someone that is on the way from one place to another so that it does not reach the intended place.</p>
</li>
<li><p><strong>flaky</strong>, behaving in a way that is strange, not responsible or not expected.</p>
</li>
<li><p><strong>malice</strong>, /`m…/, the wish to harm or upset other people<br>eg: I bear him no malice.</p>
</li>
<li><p><strong>proprietary</strong>, owned and legally controlled by a particular company.<br>eg: This is proprietary software, and you have no right to copy it without a license from the owner.</p>
</li>
<li><p><strong>overdue</strong>, not done or happening when expected or when needed; late;</p>
</li>
<li><p><strong>sentinel</strong>, a person employed to guard something</p>
</li>
<li><p><strong>the gory details</strong>, the interesting and usually personal pieces of information about a person or event.</p>
<ul>
<li>Come on, I want to know all the gory details about your date with Jon.</li>
</ul>
</li>
<li><p><strong>terse</strong>, using few words, sometimes in a way that seems rude or unfriendly.</p>
<ul>
<li>“Are you feeling any better?” “No!” was the terse reply.</li>
</ul>
</li>
<li><p><strong>descriptive</strong>, A descriptive area of study is one that is based on saying what its subject is really like, rather than on developing theories about it.</p>
</li>
<li><p><strong>declarative sentence</strong>, a sentence that makes a statement or states a fact.</p>
</li>
<li><p><strong>per se</strong>, by or of itself</p>
<ul>
<li>Research shows that it is not divorce per se that harms children, but the continuing conflict between parents.</li>
</ul>
</li>
<li><p><strong>dictate</strong>, to give orders, or tell someone exactly what they must do, with total authority.</p>
</li>
<li><p><strong>verbose</strong>, using or containing more words than are necessary.</p>
</li>
<li><p><strong>the whole shebang</strong>, the whole of something, including everything that is connected with it.</p>
</li>
<li><p><strong>hail</strong>, to publicly praise or who approval for a person or an achievement.</p>
</li>
<li><p><strong>prompt</strong>, if a computer prompts you to do something while performing a task, it gives you a message the tells you what action to take next.<br>eg: After you’ve downloaded the program, you will be prompted to restart your PC.</p>
</li>
<li><p><strong>at the expense of sth.</strong>, If you do one thing at the expense of another, doing the first thing harms the second thing.</p>
</li>
<li><p><strong>deprecate</strong>, to not approve of something or say that you do not approve of something;<br>to say that you think something is of little value or importance.</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/11/01/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/01/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">golang语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-01 19:01:42" itemprop="dateCreated datePublished" datetime="2021-11-01T19:01:42+08:00">2021-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-04 12:39:58" itemprop="dateModified" datetime="2021-11-04T12:39:58+08:00">2021-11-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="代码规则"><a href="#代码规则" class="headerlink" title="代码规则"></a>代码规则</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main<span class="comment">//文件必须声明包名</span></span><br><span class="line"><span class="keyword">import</span> （</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">）</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stockcode = <span class="number">123</span><span class="comment">//结尾不需要分号</span></span><br><span class="line">    <span class="keyword">var</span> enddate = <span class="string">&quot;2020-12-31&quot;</span></span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">&quot;Code = %d&amp;endData = %s&quot;</span></span><br><span class="line">    <span class="keyword">var</span> target_url = fmt.Sprintf(url, stockcode, enddate)<span class="comment">//类似C语言的sprintf</span></span><br><span class="line">    fmt.Println(target_url)</span><br><span class="line">    <span class="comment">//标识符以大写字母开头意味着该对象对包外可见(public)，否则则对包外不可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p><code>uint</code>,<code>uint8</code>,<code>uint16</code>,<code>uint32</code>,<code>uint64</code>,<code>int</code>,<code>int8</code>,<code>int16</code>,<code>int32</code>,<code>int64</code>,<code>float32</code>,<code>float64</code>,<code>complex64</code>（32位实数和虚数）,<code>complex128</code>（64位实数和虚数）,<code>uintptr</code>(用于存放指针)</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明:"></a>变量声明:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span><span class="comment">//如果变量没有初始化，则默认为零值</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> c, d <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span><span class="comment">//可以并行赋值</span></span><br><span class="line"><span class="keyword">var</span> e, f ,_= <span class="number">123</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;discarded&quot;</span><span class="comment">//可以是不同类型，还可以用空白标识符_来抛弃值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g, h := <span class="number">123</span>, <span class="string">&quot;hello&quot;</span><span class="comment">//用:=初始化语句的用法只能在函数体中出现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> binarynum <span class="keyword">int</span> = <span class="number">0</span>b1100<span class="comment">//二进制数字</span></span><br><span class="line"><span class="keyword">var</span> eightnum <span class="keyword">int</span> = <span class="number">0</span>o14<span class="comment">//八进制</span></span><br><span class="line"><span class="keyword">var</span> hexnum <span class="keyword">int</span> = <span class="number">0xc</span><span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><code>float32</code>，即单精度，一位符号位，八位指数位，23位尾数位</p>
<p><code>float64</code>，即双精度，一位符号位，十一位指数位，52位尾数位</p>
<p>精度主要取决于尾数位数，$$ 2^{-23} \approx 1.19*10^{-7}$$，因此float只能精确到后面6位，有效数字为7位</p>
<p>而$$2^{-52}\approx 2.22*10^{-16}$$，因此精确到小数点后15位，有效位数为16位</p>
<ul>
<li><code>math.MaxFloat32</code>和<code>math.MaxFloat64</code>分别大约是3.4e38和1.8e308</li>
<li><code>float32</code>和<code>float64</code>能表示的最小值分别是1.4e-45和4.9e-325</li>
</ul>
<h3 id="byte与rune"><a href="#byte与rune" class="headerlink" title="byte与rune"></a>byte与rune</h3><p><code>byte</code>占用一个字节，与<code>uint8</code>类型本质上没有区别</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="number">65</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">byte</span> = <span class="string">&#x27;\101&#x27;</span><span class="comment">//\是八进制前缀</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">byte</span> = <span class="string">&#x27;\x41&#x27;</span><span class="comment">//\x是十六进制前缀</span></span><br></pre></td></tr></table></figure>

<p><code>rune</code>，占用四个字节，和int32本质上也没有区别，表示一个Unicode字符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">rune</span> = <span class="string">&#x27;中&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Go语言的<code>string</code>是用utf-8编码的，英文字母占用一个字节，而中文字母占用3个字节</p>
<p>可以使用双引号或反引号包裹字符串，反引号包裹的字符串会忽略转义</p>
<p>可以用fmt的<code>%q</code>来将原生型字符串还原成解释型字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mystr0 <span class="keyword">string</span> = <span class="string">`\r\n`</span> \\原生型</span><br><span class="line"><span class="keyword">var</span> mystr2 <span class="keyword">string</span> = <span class="string">&quot;\\r\\n&quot;</span>\\解释型</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v 的解释型字符串是: %q&quot;</span>,mystr01)</span><br></pre></td></tr></table></figure>



<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>又称占位符，或者空白标识符，用下划线表示，其有三个优点</p>
<ul>
<li>不分配内存，不占用内存空间</li>
<li>不需要你为命名无用的变量名而纠结</li>
<li>多次声明不会有任何问题</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>用new创建变量和普通变量声明语句创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(Type)。</p>
<p>换言之，new函数类似是一种语法糖，而不是一个新的基础概念</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//is equivilant to</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dummy <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span><span class="comment">//数组声明</span></span><br><span class="line">arr01 := [...] <span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>:<span class="number">3</span>&#125;<span class="comment">//在下标为2处初始化为3</span></span><br></pre></td></tr></table></figure>

<p>切片是数组的抽象，其本身是引用类型。其包含容量、长度和指向底层数组的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖于数组的声明方式</span></span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice1 := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">slice2 := arr[<span class="number">1</span>:<span class="number">3</span>:<span class="number">3</span>]<span class="comment">//第三个数影响切片容量，arr[a:b:c]的切片容量为c-a</span></span><br><span class="line"><span class="comment">//空切片声明</span></span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span></span><br><span class="line">intSlice := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//使用make函数构造，make([]Type, size, cap)，第三个参数可选</span></span><br><span class="line">numbers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>,<span class="number">10</span>)<span class="comment">//声明初始长度为5，容量为10的切片</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">2</span>)<span class="comment">//追加一个元素</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">3</span>, <span class="number">4</span>)<span class="comment">//追加多个元素</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>&#125;...)<span class="comment">//追加一个切片，其中...表示解包</span></span><br><span class="line">slice = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;,myarr...)<span class="comment">//在第一个位置插入一个切片</span></span><br><span class="line">slice = <span class="built_in">append</span>(myarr[:<span class="number">5</span>],<span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">6</span>&#125;, myarr[<span class="number">5</span>:]...)...)<span class="comment">//在中间插入一个切片</span></span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure>

<p>切片的子切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">number2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">slice1 := number2[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(slice1)<span class="comment">// -&gt;[3 4]</span></span><br><span class="line">slice2 := number2[:<span class="number">3</span>]</span><br><span class="line">fmt.Println(slice2)<span class="comment">// -&gt;[1 2 3]</span></span><br><span class="line">slice3 := number2[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(slice3)<span class="comment">// -&gt;[2 3 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="const与iota"><a href="#const与iota" class="headerlink" title="const与iota"></a>const与iota</h3><p>在定义常量组时，如果不提供初始值，则表示将使用上行的表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//iota 只是在同一个 const 常量组内递增，每当有新的 const 关键字时，iota 计数会重新开始</span></span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        a = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">        b		<span class="comment">//1</span></span><br><span class="line">        c		<span class="comment">//2</span></span><br><span class="line">        d = <span class="string">&quot;ha&quot;</span> <span class="comment">//&quot;ha&quot;</span></span><br><span class="line">        e		<span class="comment">//&quot;ha&quot;</span></span><br><span class="line">        f = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">        g		<span class="comment">//100</span></span><br><span class="line">        h = <span class="literal">iota</span> <span class="comment">//7</span></span><br><span class="line">        i 		<span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>使用<code>type</code>可以定义一个类型字面量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arr3 [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>



<h3 id="Chan类型"><a href="#Chan类型" class="headerlink" title="Chan类型"></a>Chan类型</h3><p>在<code>go</code>后加一个函数，就可以创建一个线程，函数可以为已定义的，也可以是匿名的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine&quot;</span>)<span class="comment">//由于Go语言的线程是并发机制，所以这行实际来不及执行</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main start</span></span><br><span class="line"><span class="comment">main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>让线程执行的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main start</span></span><br><span class="line"><span class="comment">goroutine</span></span><br><span class="line"><span class="comment">main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><code>Chan</code>可以理解为队列，通过<code>Chan</code>，并发核心单元可以发送或者接收数据进行通讯，它的操作符是<code>&lt;-</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)<span class="comment">//声明不带缓冲的通道，进和出都会阻塞</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)<span class="comment">//声明缓冲区大小为10的通道，当长度等于10时，再进就会阻塞</span></span><br><span class="line">ch3 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)<span class="comment">//声明只读通道</span></span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)<span class="comment">//声明只写通道</span></span><br><span class="line">ch2 &lt;- <span class="string">&quot;a&quot;</span><span class="comment">//写入chan</span></span><br><span class="line">val, ok := &lt;- ch2</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">val := &lt;- ch2<span class="comment">//读取chan</span></span><br><span class="line"><span class="built_in">close</span>(ch2)<span class="comment">//关闭chan</span></span><br><span class="line"><span class="comment">//注意只读的chan不能close</span></span><br><span class="line"><span class="comment">//close以后还可以读取，但不能再写入</span></span><br></pre></td></tr></table></figure>

<p>从无缓存的 channel 中读取消息会阻塞，直到有 goroutine 向该 channel 中发送消息；</p>
<p>同理，向无缓存的 channel 中发送消息也会阻塞，直到有 goroutine 从 channel 中读取消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;a&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ele &lt;- ch</span><br><span class="line">        fmt.Println(ele)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">1</span>* time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用range遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> ch&#123;<span class="comment">//一直从ch中读取数据直到该ch被close</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a>map类型</h3><p>map是哈希表的一个实现，这就要求它的每个映射里的key都是唯一的，可以使用<code>==</code>和<code>!=</code>来进行判等操作，换句话说key必须是可哈希的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span><span class="comment">//纯声明，此时scores的值为nil，无法赋值</span></span><br><span class="line">scores1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line">scores2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scores2[<span class="string">&quot;english&quot;</span>] = <span class="number">80</span><span class="comment">//添加元素</span></span><br><span class="line">scores2[<span class="string">&quot;chinese&quot;</span>] = <span class="number">85</span></span><br><span class="line">scores2[<span class="string">&quot;english&quot;</span>] = <span class="number">140</span><span class="comment">//更新元素</span></span><br><span class="line">fmt.Peintln(scores2[<span class="string">&quot;english&quot;</span>]) <span class="comment">//根据key读取value，如果key不存在则返回这个value的零值</span></span><br><span class="line"><span class="built_in">delete</span>(scores2, <span class="string">&quot;english&quot;</span>)<span class="comment">//根据key删除元素，如果key不存在则静默处理</span></span><br><span class="line">chinese, ok = scores2[<span class="string">&quot;chinese&quot;</span>]<span class="comment">//ok表示是否存在</span></span><br></pre></td></tr></table></figure>

<p>对字典进行循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scores1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="keyword">for</span> subject, score := <span class="keyword">range</span> scores1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> subject := <span class="keyword">range</span> scores1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, score := <span class="keyword">range</span> scores1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>在Go语言中，不同类型间无法比较，因而以下表达式是错误的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译错误的表达式</span></span><br><span class="line"><span class="keyword">var</span> male <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> male == <span class="number">1</span> &#123;<span class="comment">//不能将布尔类型与整数类型进行比较</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>Go要求<code>else if</code> 或<code>else </code>两边的花括号必须在同一行，且要求条件表达式必须严格返回布尔类型的数据</p>
<p>在if 里可以允许先运行一个表达式，取得变量后，再对其进行判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age := <span class="number">18</span>; age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;已经成年了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch从第一个判断表达式为true 的case开始执行，不需要break</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of x is %T&quot;</span>,i)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of x is int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">float64</span>:</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of x is func(int)&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:<span class="comment">//多条件匹配</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;The type of x is bool or string&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Unknown type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The type of x is &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要强制执行下一条的时候可以使用fallthrough</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>



<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for后面可以接的表达式有：</p>
<ul>
<li>条件表达式</li>
<li>三个表达式(init; condition; increment)</li>
<li>range 表达式 </li>
<li>不接表达式</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;<span class="comment">//类似于C中的while</span></span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;xiong&quot;</span>, <span class="string">&quot;fang&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> arr &#123;<span class="comment">//range返回值为 index,item，在这里不需要index</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;hello, %s \n&quot;</span>,item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>Go语言的goto语句与标签之间不能有变量声明，否则会编译错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">goto</span> flag</span><br><span class="line"><span class="keyword">var</span> say = <span class="string">&quot;This is wrong&quot;</span></span><br><span class="line">flag:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="defer延时调用"><a href="#defer延时调用" class="headerlink" title="defer延时调用"></a>defer延时调用</h3><p>在<code>defer</code>后跟一个表达式，意味着在所处函数执行完之后再调用该表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> myfunc()</span><br><span class="line">    fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defer只是延时调用，变量已经传递过去了，且是反序调用，后进先出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;go&quot;</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(name)</span><br><span class="line">    name = <span class="string">&quot;rust&quot;</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(name)</span><br><span class="line">    name = <span class="string">&quot;c++&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">c++</span></span><br><span class="line"><span class="comment">rust</span></span><br><span class="line"><span class="comment">go</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>defer在return之后调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;go&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		name = <span class="string">&quot;python&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The name in myfunc is &quot;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    myname := myfunc()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The name in main is &quot;</span>, name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The myname in main is &quot;</span>, myname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 的用法类似于IO多路复用，可以同时监听的多个channel的消息状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> &lt;- ch2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- <span class="number">10</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>select 可以同时监听多个channel的写入或读取</li>
<li>执行select时，若只有一个case通过，则执行这个case块</li>
<li>若有多个case通过，则伪随机挑选一个case执行</li>
<li>若所有case都阻塞，且定义了default模块，则执行default模块。若无default模块则select语句阻塞</li>
<li>使用break会跳出select块</li>
</ul>
<p>设置超时时间：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(chn <span class="keyword">struct</span> &#123;&#125;)</span><br><span class="line"><span class="comment">//finish task while send msg to ch</span></span><br><span class="line"><span class="keyword">go</span> doTask(ch)</span><br><span class="line">timeout := time.After(<span class="number">5</span> * time.Second)<span class="comment">//time.After返回一个5s后产生信号的管道</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch:</span><br><span class="line">    fmt.Println(<span class="string">&quot;task finished.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;- timout:</span><br><span class="line">    fmt.Println(<span class="string">&quot;task timeout.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>quite channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msgCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span> &#123;&#125;)</span><br><span class="line">quitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- msgCh:</span><br><span class="line">        doWork()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quitCh:</span><br><span class="line">        finish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以返回多个值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    c := a + b</span><br><span class="line">    <span class="keyword">return</span> c, <span class="string">&quot;successfully added&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的返回值也可以预先定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ad</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(c <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者。接收者可以是值，也可以是指针</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="panic函数"><a href="#panic函数" class="headerlink" title="panic函数"></a>panic函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;Some error here&quot;</span>)<span class="comment">//panic: Some error here</span></span><br></pre></td></tr></table></figure>

<h3 id="recover函数"><a href="#recover函数" class="headerlink" title="recover函数"></a>recover函数</h3><p>recover函数可以捕获异常，恢复程序或做收尾工作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set_data</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//recover()只能在defer域中才能生效</span></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> arr [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    arr[x] = <span class="number">88</span><span class="comment">//故意制造数组越界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    set_data(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;everything is ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">runtime error: index out of range [20] with length 10</span></span><br><span class="line"><span class="comment">everything is ok</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct 结构"></a>struct 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">    name, gender <span class="keyword">string</span><span class="comment">//相同类型的字段可以合并</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    mother, father *Profile</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(person Profile)</span> <span class="title">FmtProfile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;name: &quot;</span>,person.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;age: &quot;</span>,person.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;gender: &quot;</span>,person.gender)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    xf := Profile&#123;name: <span class="string">&quot;熊昉&quot;</span>&#125;<span class="comment">//未被赋值的字段会自动赋为零值</span></span><br><span class="line">    xf.gender = <span class="string">&quot;male&quot;</span></span><br><span class="line">    xf.age = <span class="number">18</span></span><br><span class="line">    xf.FmtProfile()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改变对象的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(person *Profile)</span> <span class="title">increase_age</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用组合的方式实现继承"><a href="#用组合的方式实现继承" class="headerlink" title="用组合的方式实现继承"></a>用组合的方式实现继承</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> company <span class="keyword">struct</span> &#123;</span><br><span class="line">    companyName <span class="keyword">string</span></span><br><span class="line">    companyAddr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> staff <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    company<span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口指定了一个类型应该具有的方法，并由该类型决定如何实现这些方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Nokia <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Nokia )</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I&#x27;m a phone called Nokia&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>普通的接口都有方法，而空接口没有定义任何方法，因此我们可以说所有类型都至少实现了空接口</p>
<p>对于空接口，其值和类型都是<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;type: %T, value: %v&quot;</span>,i,i)<span class="comment">//type: &lt;nil&gt;, value: &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>

<p>不能把空接口类型的对象赋值给一个固定类型，也不能对空接口类型的对象切片</p>
<p>当使用空接口来接收任意类型的参数时，它的静态类型是<code>interface&#123;&#125;</code>，但动态类型我们并不知道，因此需要使用类型断言 </p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言可以</p>
<ul>
<li>检查<code>i</code>是否为<code>nil</code></li>
<li>检查<code>i</code>存储的值是否为某个类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">10</span></span><br><span class="line">t1, ok := i.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(t1, <span class="string">&quot;-&quot;</span>, ok)<span class="comment">//10-true</span></span><br><span class="line">t2, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(t2, <span class="string">&quot;-&quot;</span>, ok)<span class="comment">//-false</span></span><br></pre></td></tr></table></figure>

<h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>在需要区分多种类型的时候，用<code>type switch</code>断言会更简单高效</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> x := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Println(x, <span class="string">&quot;is int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Println(x, <span class="string">&quot;is string&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        fmt.Println(x, <span class="string">&quot;is nil&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(x <span class="string">&quot;not type matched&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型断言仅能对静态类型为空接口（<code>interface&#123;&#125;</code>）的对象进行断言</p>
<p>断言完成后，实际上会返回静态类型为你断言的类型的对象，而原有的静态类型仍是空接口类型</p>
<h3 id="接口实现多态"><a href="#接口实现多态" class="headerlink" title="接口实现多态"></a>接口实现多态</h3><p>一个接口在不同对象上的不同表现就是多态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Good <span class="keyword">interface</span> &#123;</span><br><span class="line">    settleAccount() <span class="keyword">int</span></span><br><span class="line">    orderInfo() <span class="keyword">string</span></span><br><span class="line">&#125;<span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    quantity <span class="keyword">int</span></span><br><span class="line">    price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> FreeGift <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    quantity <span class="keyword">int</span></span><br><span class="line">    price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span><span class="title">settleAccount</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phtone.quantity * phtone.price</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span> <span class="title">orderInfo</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你要购买&quot;</span> + strconv.Itoa(phone.quantity) + <span class="string">&quot;个&quot;</span> + phone.name + <span class="string">&quot;计:&quot;</span> + </span><br><span class="line">    strconv.Itoa(phone.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift FreeGift)</span> <span class="title">settleAccount</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift FreeGift)</span> <span class="title">orderinfo</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你要购买&quot;</span> + strconv.Itoa(gift.quantity) + <span class="string">&quot;个&quot;</span> + gift.name + <span class="string">&quot;计:&quot;</span> + </span><br><span class="line">    strconv.Itoa(gift.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现了这两个方法后，这两个类型在Go语言看来就都是商品类型了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateAllPrice</span><span class="params">(goods []Good)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">     <span class="keyword">var</span> allPrice <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,good := <span class="keyword">range</span> goods&#123;</span><br><span class="line">        fmt.Println(good.orderInfo())</span><br><span class="line">        allPrice += good.settleAcccount()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allPrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>Tag 可以用来增强结构体的定义，Tag会带上一些元信息，不管转义字符串还是原始字符串都可以用来当Tag</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    f1		<span class="keyword">string</span> 	<span class="string">&quot; f one&quot;</span></span><br><span class="line">    f2 		<span class="keyword">string</span></span><br><span class="line">    f3 		<span class="keyword">string</span> 	<span class="string">`f three`</span></span><br><span class="line">    f4,f5	<span class="keyword">int64</span>	<span class="string">`f four and five`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tags可以由键值对组成，通过使用这样的格式可以使用<code>LookUp</code>函数获取键值对的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    f <span class="keyword">string</span> <span class="string">`one:&quot;1&quot; two:&quot;2&quot; blank: &quot;&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Tag获取方式"><a href="#Tag获取方式" class="headerlink" title="Tag获取方式"></a>Tag获取方式</h3><p>需引入<code>reflect</code>包，通过<code>TypeOf</code>函数绑定类型，通过<code>FieldByName</code>函数获取对应字段的field</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(T&#123;&#125;)</span><br><span class="line">f1, _ := t.FieldByName(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line">fmt.Println(f1.Tag)<span class="comment">//f one</span></span><br><span class="line">f4, _ := t.FieldByName(<span class="string">&quot;f4&quot;</span>)</span><br><span class="line">fmt.Println(f4.Tag)<span class="comment">//f four and five</span></span><br><span class="line">f5, _ := t.FieldByName(<span class="string">&quot;f5&quot;</span>)</span><br><span class="line">fmt.Println(f5.Tag)<span class="comment">//f four and five</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Lookup</code>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(T2&#123;&#125;)</span><br><span class="line">f, _ := t.FieldByName(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">fmt.Println(f.Tag)<span class="comment">//one:&quot;1&quot; two:&quot;2&quot; blank: &quot;&quot;</span></span><br><span class="line">v, ok := f.Tag.Lookup(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;%s, %t&quot;</span>, v, ok)</span><br></pre></td></tr></table></figure>

<p><code>Get</code>方法只是简单的包装了<code>Lookup</code>，但是丢弃了是否成功的结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tag StructTag)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    v, _ := tag.Lookup(key)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>先看维基百科上的定义</p>
<blockquote>
<p>在计算机科学中，反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。</p>
</blockquote>
<p>Go语言圣经：</p>
<blockquote>
<p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制</p>
</blockquote>
<h3 id="reflect-Value类型和reflect-Type类型"><a href="#reflect-Value类型和reflect-Type类型" class="headerlink" title="reflect.Value类型和reflect.Type类型"></a>reflect.Value类型和reflect.Type类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>,reflect.TypeOf(x))<span class="comment">//type: float64</span></span><br><span class="line"><span class="comment">//在reflect.TypeOf的函数签名里包含一个空接口</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>,reflect.ValueOf(x))<span class="comment">//value: 3.4</span></span><br></pre></td></tr></table></figure>

<h3 id="kind方法"><a href="#kind方法" class="headerlink" title="kind方法"></a>kind方法</h3><p><code>reflect.Value</code>和<code>reflect.Type</code>都有一个名为<code>Kind</code>的方法，它会返回一个常量，表示<strong>底层数据的类型</strong></p>
<p><code>Value</code>类型也有一些类似于<code>Int</code>、<code>Float</code>的方法，用来提取底层的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure>

<h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice()"></a>Slice()</h3><p><code>Slice()</code>跟其他类型转换的函数不一样，它返回的还是<code>reflect.Value</code>反射对象</p>
<h3 id="Interface方法"><a href="#Interface方法" class="headerlink" title="Interface方法"></a>Interface方法</h3><p>可以根据一个<code>reflect.Value</code>类型的变量恢复其接口类型的值，事实上，这个方法会把type和value信息打包并填充到一个接口变量中，然后返回</p>
<p>其函数声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CanSet方法"><a href="#CanSet方法" class="headerlink" title="CanSet方法"></a>CanSet方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">34</span></span><br><span class="line">v := reflect.ValueOf(x)<span class="comment">//传递的是x的拷贝，而非x本身</span></span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())<span class="comment">//settability of v: false</span></span><br></pre></td></tr></table></figure>

<p>传递指针则可写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())<span class="comment">//settability of v: true</span></span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface())<span class="comment">//7.1</span></span><br><span class="line">fmt.Println(x)<span class="comment">//7.1</span></span><br></pre></td></tr></table></figure>



<h2 id="json包"><a href="#json包" class="headerlink" title="json包"></a>json包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mapA := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span>&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;lettuce&quot;</span> :<span class="number">7</span>&#125;</span><br><span class="line">    mapB,_:=json.Marshal(mapA)<span class="comment">//编码</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(mapB))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> response <span class="keyword">struct</span>&#123;</span><br><span class="line">    PageNumber <span class="keyword">int</span> <span class="string">`json:&quot;page&quot;`</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/10/29/rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/29/rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">rust基本语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-29 11:08:02" itemprop="dateCreated datePublished" datetime="2021-10-29T11:08:02+08:00">2021-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-31 13:48:03" itemprop="dateModified" datetime="2021-10-31T13:48:03+08:00">2021-10-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>除<code>byte</code>外的所有数字字面值允许使用类型后缀，如<code>57u8</code></p>
<p>在debug模式中，整形溢出会导致程序<code>panic</code>。而release模式中，则会进行回环（<code>Wrapping</code>）</p>
<p>如果确实需要整形溢出，可以使用<code>Wrapping</code>类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = Wrapping(<span class="built_in">i32</span>::MAX);<span class="comment">//用标准库的Wrapping&lt;T&gt;结构体包装基本数据类型的数字</span></span><br><span class="line"><span class="comment">//或者直接调用.wrapping_***(...)成员方法来完成算术运算</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">i32</span>::MAX.wrapping_add(<span class="number">2</span>), <span class="built_in">i32</span>::MIN+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">123_4</span>; <span class="comment">//整数中可以出现下划线</span></span><br><span class="line"><span class="keyword">let</span> tup:(<span class="built_in">i32</span>,<span class="built_in">f64</span>,<span class="built_in">u8</span>) = (<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);<span class="comment">//元组可以包含不同种类的数据</span></span><br><span class="line"><span class="comment">//tup.0等于500。。。</span></span><br><span class="line"><span class="keyword">let</span> (x,y,z) = tup;<span class="comment">//解构元组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="comment">//数组包含同类型数据</span></span><br><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="comment">//[元素类型;元素数量]</span></span><br><span class="line"><span class="comment">//当索引超出了下标范围时会发生一个运行时错误</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>str是Rust核心语言类型，常常以引用的形式出现（&amp;str）</p>
<p>凡是用双引号包括的字符串常量的类型都是&amp;str</p>
<p>String 则有更完善的功能</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = &amp;s1[..];<span class="comment">//从String类型转为&amp;str类型</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>+</code>号运算符进行简单的拼接</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2;<span class="comment">//s1 在此之后不可用</span></span><br></pre></td></tr></table></figure>

<p><code>+</code>运算符使用了<code>add</code>函数，这个函数签名看起来像这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以能在<code>add</code>调用中使用<code>&amp;s2</code>是因为<code>&amp;String</code>可以被强制转换成<code>&amp;str</code></p>
<p>对于更为复杂的字符串链接，可以使用<code>format!</code>宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>,s1,s2,s3);</span><br><span class="line"><span class="comment">//format!与println!的工作原理相同，不同之处是其返回一个带有结果内容的String</span></span><br></pre></td></tr></table></figure>

<p>使用<code>parse</code>或turbo fish语法实现从字符串到其他类型的转换：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//只要目标类型实现了FromStr特性</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> parsed: <span class="built_in">i32</span> = <span class="string">&quot;5&quot;</span>.parse().unwrap();</span><br><span class="line">    <span class="keyword">let</span> turbo_parsed = <span class="string">&quot;10&quot;</span>.parse::&lt;<span class="built_in">i32</span>&gt;().unwrap();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> sum = parsed + turbo_parsed;</span><br><span class="line">    <span class="built_in">println!</span>&#123;<span class="string">&quot;Sum: &#123;:?&#125;&quot;</span>,sum&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部表现"><a href="#内部表现" class="headerlink" title="内部表现"></a>内部表现</h3><p><code>String</code>是一个<code>Vec&lt;u8&gt;</code>的封装，而Unicode是使用两个字节表示一个字，因此<code>String</code>不支持下标访问</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>元组常用于非定义的多值传递，而结构体用于定义对象规范，结构体的每个成员叫做“字段”</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Site</span></span>&#123;</span><br><span class="line">    domain: <span class="built_in">String</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    nation: <span class="built_in">String</span>,</span><br><span class="line">    found: <span class="built_in">u32</span></span><br><span class="line">    <span class="comment">//每个字段定义后用&quot;,&quot;分隔</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体实例</span></span><br><span class="line"><span class="keyword">let</span> mysite = Site&#123;</span><br><span class="line">    <span class="comment">//key: value 语法</span></span><br><span class="line">    domain: <span class="built_in">String</span>::from(<span class="string">&quot;ajsoabk.xyz&quot;</span>),</span><br><span class="line">    name: <span class="built_in">String</span>::from(<span class="string">&quot;Ajsoabk&quot;</span>),</span><br><span class="line">    nation: <span class="built_in">String</span>::from(<span class="string">&quot;China&quot;</span>),</span><br><span class="line">    found: <span class="number">2020</span></span><br><span class="line">&#125;;<span class="comment">//记得分号</span></span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> domain = <span class="built_in">String</span>(<span class="string">&quot;ajsoabk.xyz&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">String</span>(<span class="string">&quot;Ajsoabk&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> mysite = Site&#123;</span><br><span class="line">    domain,<span class="comment">//有同名变量时可以简化</span></span><br><span class="line">    name,<span class="comment">//等同于name: name</span></span><br><span class="line">    nation: <span class="built_in">String</span>:from(<span class="string">&quot;China&quot;</span>),</span><br><span class="line">    found: <span class="number">2020</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结构体更新语法</span></span><br><span class="line"><span class="keyword">let</span> newsite = Site&#123;</span><br><span class="line">	domain: <span class="built_in">String</span>(<span class="string">&quot;www.ajsoabk.xyz&quot;</span>),</span><br><span class="line">    ..mysite</span><br><span class="line">&#125;;<span class="comment">//这种语法需要至少重新设定一个字段的值</span></span><br></pre></td></tr></table></figure>

<h4 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h4><p>形式是元组的结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">f64</span>,<span class="built_in">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;black = (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;</span>,black.<span class="number">0</span>,black.<span class="number">1</span>,black.<span class="number">2</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;origin = (&#123;&#125;,&#123;&#125;)&quot;</span>,origin.<span class="number">0</span>,origin.<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="输出结构体"><a href="#输出结构体" class="headerlink" title="输出结构体"></a>输出结构体</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span><span class="comment">//导入调试库</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> rect1= Rectangle&#123;width:<span class="number">30</span>,height:<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>,rect1);<span class="comment">//使用&#123;:?&#125;占位符输出结构体</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:#?&#125;&quot;</span>,rect1):<span class="comment">//使用&#123;:#?&#125;占位符分行输出结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h4> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">	width: <span class="built_in">u32</span>,</span><br><span class="line">    height:<span class="number">32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Rectangle&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span>&#123;<span class="comment">//结构体方法的第一个参数必须是&amp;self,不需要声明类型</span></span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> ret1 = Rectangle &#123;width : <span class="number">30</span>,height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1&#x27;s area is &#123;&#125;&quot;</span>,rect1.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体关联函数"><a href="#结构体关联函数" class="headerlink" title="结构体关联函数"></a>结构体关联函数</h4><p>结构体关联函数与结构体方法的区别是结构体关联函数在impl块中却没有&amp;self 参数</p>
<p>这种函数不依赖实例，但却需要声明是在哪个impl块中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Rectangle&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(width: <span class="built_in">u32</span>,height: <span class="built_in">u32</span>) -&gt; Rectangle&#123;</span><br><span class="line">        Rectanlge&#123;width,height&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> rect = Rectangle::create(<span class="number">30</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>impl块可以写多次，相当于将其拼接</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于非枚举类，需要设置缺省情况</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        <span class="string">&quot;abc&quot;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Yes&quot;</span>),</span><br><span class="line">        _ =&gt; &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Option、Result与kind"><a href="#Option、Result与kind" class="headerlink" title="Option、Result与kind"></a>Option、Result与kind</h3><p>Option类包含None及Some，用于可能有空值的情况</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_division</span></span>(dividend: <span class="built_in">i32</span>,divisor: <span class="built_in">i32</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Some</span>(dividend / divisor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">try_division</span></span>(dividend: <span class="built_in">i32</span>,divisor: <span class="built_in">i32</span>)&#123;</span><br><span class="line">    <span class="keyword">match</span> checked_division(dividend,divisor)&#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; / &#123;&#125; failed!&quot;</span>,dividend,divisor);</span><br><span class="line">        <span class="literal">Some</span>(quotient) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; / &#123;&#125; = &#123;&#125;&quot;</span>,dividend, divisor, quotient)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    try_division(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">    try_division(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Result类则可以包含相关错误信息，还有专门的<code>?</code>操作符</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(i: <span class="built_in">i32</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, <span class="built_in">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123; <span class="literal">Ok</span>(i) &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="literal">Err</span>(<span class="literal">false</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">g</span></span>(i: <span class="built_in">i32</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, <span class="built_in">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> t = f(i)?;<span class="comment">//在Result出现异常的时候直接返回异常</span></span><br><span class="line">    <span class="literal">Ok</span>(t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> r = g(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(v) = r&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Ok: g(10000) = &#123;&#125;&quot;</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Result类还有kind方法可以确定错误类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_text_from_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> str_file = read_text_from_file(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> str_file&#123;</span><br><span class="line">        <span class="literal">Ok</span>(s) =&gt; prinln!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> e.kind()&#123;<span class="comment">//根据错误类型进行相应处理</span></span><br><span class="line">                io::ErrorKind::NotFound =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;No such file&quot;</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                _ =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Cannot read the file&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v= <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="comment">//用vec!宏进行初始化</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v:<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();<span class="comment">//新建vector变量</span></span><br><span class="line">v.push(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>,v[<span class="number">0</span>]);<span class="comment">//访问下标为0的位置上的元素，若超出则会崩溃</span></span><br><span class="line"><span class="comment">//或者使用get方法，可以自己选择超出后的处理方法</span></span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>,i),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="控制流语句（if，while，for，loop，if-let，-match）"><a href="#控制流语句（if，while，for，loop，if-let，-match）" class="headerlink" title="控制流语句（if，while，for，loop，if let， match）"></a>控制流语句（if，while，for，loop，if let， match）</h2><h3 id="lf-else-作为表达式"><a href="#lf-else-作为表达式" class="headerlink" title="lf-else 作为表达式"></a>lf-else 作为表达式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the max num in &#123;&#125; and &#123;&#125; is &#123;&#125;&quot;</span>,a,b,<span class="keyword">if</span> a &gt; b &#123;a&#125; <span class="keyword">else</span> &#123;b&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="使用loop查找"><a href="#使用loop查找" class="headerlink" title="使用loop查找"></a>使用loop查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let s = [&#x27;X&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;n&#x27;,&#x27;g&#x27;,&#x27;F&#x27;,&#x27;a&#x27;,&#x27;n&#x27;,&#x27;g&#x27;];</span><br><span class="line">let mut i = 0;</span><br><span class="line">let location = loop &#123;</span><br><span class="line">  	if(s[i] == &#x27;F&#x27;)&#123;</span><br><span class="line">        break i</span><br><span class="line">    &#125;</span><br><span class="line">    i += 1;</span><br><span class="line">&#125;;</span><br><span class="line">println!(&quot;The location of \&#x27;F\&#x27; is &#123;&#125;&quot;,location);</span><br></pre></td></tr></table></figure>

<h3 id="match-和if-let"><a href="#match-和if-let" class="headerlink" title="match 和if let"></a>match 和if let</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),<span class="comment">//匹配的同时绑定i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匹配必须穷尽</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">	<span class="literal">Some</span>(<span class="number">1</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    _ =&gt; (),<span class="comment">//所有剩余情况的匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>if let </code>来进行匹配且无需穷尽</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x:<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = x &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Some</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="所有权机制"><a href="#所有权机制" class="headerlink" title="所有权机制"></a>所有权机制</h2><ul>
<li>Rust中的每个值都有一个变量，称为其所有者</li>
<li>一次只能有一个所有者</li>
<li>当所有者不在程序运行范围内时，该值将被删除</li>
</ul>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="comment">//此时栈中有两个值5，因为int是基本数据类型，基本数据类型具有Copy特性</span></span><br><span class="line"><span class="comment">//Copy特性保证其对象在被赋值给其他对象后仍然可用</span></span><br></pre></td></tr></table></figure>

<p>整型、布尔类型、浮点型、字符类型和仅包含以上类型的元组是基本数据类型</p>
<p>但如果发生交互的数据在堆中就是另外一种情况</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//&quot;Hello&quot;可以认为是类似于长度不确定的数据，需要在堆中存储</span></span><br><span class="line"><span class="keyword">let</span> s2 = s1;<span class="comment">//由于两者都指向堆中变量，因此为了防止两次释放，s1被赋值给s2后，s1已经无效了</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; World!&quot;</span>,s1); <span class="comment">//错误！s1已经失效</span></span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>,s1,s2);</span><br></pre></td></tr></table></figure>

<h3 id="涉及函数的所有权机制"><a href="#涉及函数的所有权机制" class="headerlink" title="涉及函数的所有权机制"></a>涉及函数的所有权机制</h3><p>如果讲变量当作参数传入函数，那么它和移动的效果是一样的</p>
<p>被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放</p>
<h3 id="引用与租借"><a href="#引用与租借" class="headerlink" title="引用与租借"></a>引用与租借</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 is &#123;&#125;, s2 is &#123;&#125;&quot;</span>,s1,s2);</span><br></pre></td></tr></table></figure>

<p>&amp;可以取变量的引用，引用并没有在栈中复制变量的值</p>
<p>引用不会获得值的所有权。引用只能租借值的所有权，引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一段不正确的代码</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="keyword">let</span> s3 = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);<span class="comment">//错误，所有权已经转给s3，s2需要重新从s3租借所有权</span></span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s2 = &amp;s1;</span><br><span class="line"><span class="keyword">let</span> s3 = s1;</span><br><span class="line">s2 = &amp;s3;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>如果尝试利用租借来的权力来修改数据会被阻止</p>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><p>可以使用可变引用来修改数据</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = &amp;<span class="keyword">mut</span> s1;</span><br><span class="line">s2.push_str(<span class="string">&quot; World!&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br></pre></td></tr></table></figure>

<p>可变引用不允许多重引用(不管是可变还是非可变）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一段不正确的代码</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;<span class="comment">//错误，可变引用不允许多重引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,r1,r2);</span><br></pre></td></tr></table></figure>

<p>主要是为了防止在并发状态下发生数据访问碰撞</p>
<h3 id="错误的悬垂引用"><a href="#错误的悬垂引用" class="headerlink" title="错误的悬垂引用"></a>错误的悬垂引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s =<span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &amp;s<span class="comment">//此时s已经被释放，但s的引用却被返回，这个引用所指向的值已经不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会发现这种错误</p>
<h2 id="Rust-组织管理"><a href="#Rust-组织管理" class="headerlink" title="Rust 组织管理"></a>Rust 组织管理</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nation&#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">mod</span> government&#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">govern</span></span>()&#123;&#125;<span class="comment">//pub公开路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mod</span> congress&#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">legislate</span></span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mod</span> court&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">judicial</span></span>()&#123;</span><br><span class="line">            super::congress::legislate();<span class="comment">//super进入上一级</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> congress::legislate;<span class="comment">//pub use使外部代码也能直接使用新路径</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">use</span> nation::&#123;government::govern,legislate&#125;;<span class="comment">//嵌套路径</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;<span class="comment">//可用self指定自身</span></span><br><span class="line"><span class="keyword">use</span> std::collections::*;<span class="comment">//用*指定所有公有项</span></span><br></pre></td></tr></table></figure>

<h2 id="Rust泛型与特性"><a href="#Rust泛型与特性" class="headerlink" title="Rust泛型与特性"></a>Rust泛型与特性</h2> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T,U&gt; &#123;</span><br><span class="line">    x:T,</span><br><span class="line">    y:U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T,U&gt; Point&lt;T,U&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mixup</span></span>&lt;V,W&gt;(<span class="keyword">self</span>,other: Point&lt;V,W&gt;) -&gt; Point&lt;T,W&gt;&#123;</span><br><span class="line">        Point&#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以实现多个特性，每个impl块只能怪为一个类实现一个特性</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Comparable</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>(&amp;<span class="keyword">self</span>, object: &amp;<span class="keyword">Self</span>) -&gt; <span class="built_in">i8</span>;<span class="comment">//描述Comparable特性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">max</span></span>&lt;T: Comparable&gt; (array: &amp;[T]) -&gt; &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> max_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt; array.len() &#123;</span><br><span class="line">        <span class="keyword">if</span> array[i].compare(&amp;array[max_index]) &gt; <span class="number">0</span>&#123;</span><br><span class="line">            max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;array[max_index]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Comparable <span class="keyword">for</span> <span class="built_in">f64</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>(&amp;<span class="keyword">self</span>, object: &amp;<span class="built_in">f64</span>) -&gt; <span class="built_in">i8</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> &amp;<span class="keyword">self</span> &gt; &amp;object &#123;<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> &amp;<span class="keyword">self</span> == &amp;object &#123;<span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;-<span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1.0</span>,<span class="number">3.0</span>,<span class="number">5.0</span>,<span class="number">4.0</span>,<span class="number">2.0</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;maximum of arra is &#123;&#125;&quot;</span>,max(&amp;arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认特性"><a href="#默认特性" class="headerlink" title="默认特性"></a>默认特性</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Descriptive</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">describe</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">&quot;[Object]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Descriptive <span class="keyword">for</span> Person&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">describe</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>,<span class="keyword">self</span>.name,<span class="keyword">self</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> cali = Person&#123;</span><br><span class="line">        name: <span class="built_in">String</span>::from(<span class="string">&quot;Cali&quot;</span>),</span><br><span class="line">        age: <span class="number">24</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,cali.describe());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ajsoabk.xyz/2021/10/26/%E5%81%A5%E8%BA%AB%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ajsoabk">
      <meta itemprop="description" content="我在我心的孤寂里，听见你的叹息了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="归因">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/26/%E5%81%A5%E8%BA%AB%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">健身知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-26 13:24:46" itemprop="dateCreated datePublished" datetime="2021-10-26T13:24:46+08:00">2021-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-29 23:22:48" itemprop="dateModified" datetime="2021-10-29T23:22:48+08:00">2021-10-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="所有动作都需要感受臀部发力！！！"><a href="#所有动作都需要感受臀部发力！！！" class="headerlink" title="所有动作都需要感受臀部发力！！！"></a>所有动作都需要感受臀部发力！！！</h3><table>
<thead>
<tr>
<th>动作</th>
<th>技巧</th>
<th>目的</th>
<th>肌群</th>
<th>进阶练习</th>
</tr>
</thead>
<tbody><tr>
<td><strong>平板直抬腿</strong></td>
<td>注意抬起加速<br />注意保持直腿及上身稳定</td>
<td>提高爆发力，加快大腿抓地速度</td>
<td>臀大肌及大腿后侧肌群</td>
<td>双腿离地</td>
</tr>
<tr>
<td><strong>行进箭步蹲</strong></td>
<td>注意动作完成度及离心加速<br />注意上身直立及整体稳定<br />注意后腿膝盖不要用力磕地，点到为止</td>
<td>提高爆发力，训练抓地速度</td>
<td>臀大肌及股四头肌</td>
<td>负重</td>
</tr>
<tr>
<td><strong>平地提踵</strong></td>
<td>注意高抬慢放，脚后跟不要触地</td>
<td>提高踝关节稳定性及压脚掌动作的质量</td>
<td>腓肠肌等小腿肌群</td>
<td>负重、垫高前脚掌</td>
</tr>
<tr>
<td><strong>坐姿交替直抬腿</strong></td>
<td>注意顶峰收缩及高抬慢放</td>
<td>提高直腿稳定性及柔韧性</td>
<td>股四头肌，腹肌</td>
<td>双腿离地</td>
</tr>
<tr>
<td><strong>单脚提踵</strong></td>
<td>同平地提踵，尤其注意稳定性维持</td>
<td>针对性提高单脚脚掌力量</td>
<td>腓肠肌等小腿肌群</td>
<td>负重、垫高前脚掌</td>
</tr>
<tr>
<td><strong>单脚侧蹲</strong></td>
<td>所抬脚不要触地，尤其注意稳定性维持</td>
<td>针对性提高单腿侧向稳定性</td>
<td>臀大肌、股四头肌等肌群</td>
<td>已经够难了</td>
</tr>
<tr>
<td><strong>靠墙静蹲</strong></td>
<td>注意上身贴墙，腿部大约成直角，手不要放在腿上防止给膝盖更大压力</td>
<td>提高腿部耐力，保护膝盖</td>
<td>大部分大腿肌群</td>
<td>加长时间</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ajsoabk</p>
  <div class="site-description" itemprop="description">我在我心的孤寂里，听见你的叹息了</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ajsoabk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
